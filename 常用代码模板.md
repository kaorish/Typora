# 由数据范围反推算法复杂度以及算法内容

一般ACM或者笔试题的时间限制是1秒或2秒。在这种情况下，C++代码中的操作次数控制在 $10^7\sim10^8$ 为最佳。
 下面给出在不同数据范围下，代码的时间复杂度和算法该如何选择： 1. $n\leq30$,指数级别，dfs+剪枝，状态压缩dp

 $2.n\leq100=>O(n^{3})$, floyd, dp, 高斯消元$3.n\leq1000=>O(n^2)$,$O(n^2logn)$, dp,二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford

 $4.n\leq10000=>O(n*\sqrt{n})$,块状链表、分块、莫队
 $5.n\leq100000=>O(nlogn)=>$ 各种sort，线段树、树状数组、set/map、heap、拓扑排序、dijkstra+heap、

prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树锥剖分、动态树$6.n\leq1000000=>O(n)$,以及常数较小的 $O(nlogn)$ 算法 => 单调队列、 hash、双指针扫描、BFS、并查集，

kmp、AC自动机，常数比较小的$O(nlogn)$ 的做法：sort、树状数组、heap、dijkstra、spfa
7.$n\leq10000000=>O(n)$,双指针扫描、kmp、AC自动机、线性筛素数8.$n\leq10^{9}=>O(\sqrt{n})$,判断质数
 $9.n\leq10^{18}=>O(logn)$,最大公约数，快速幂，数位DP
 $10.\:n\leq10^{1000}=>O((logn)^2)$, 高精度加减乘除
 $11.n\leq10^{100000}\Rightarrow O(logk\times loglogk)$,$k$表示位数，高精度加减、FFT/NTT



# 一些常见的代码错误分析

1. 数据过大，没有开long long(遇事不决开long long)
2. 读入读出有问题
3. 边界越界，检查一下是否超出范围
4. 忘记更新，或者忘记回溯
5. 数组范围过大，不知道怎么越界，采用vector或者set，map可参考<[Problem - C - Codeforces](https://codeforces.com/contest/1927/problem/C)>



# 一些解题思路的分享

1. 首先就是要**读懂题目**，理解题目意思比什么都重要
2. **带入样例**，再次理解题目，**观察是否有规律**，这里举一个例子<[Problem - D - Codeforces](https://codeforces.com/contest/1933/problem/D)>题目基本意思就是给你一个数组，你可以任意改变数组中元素的顺序，让数组中的数从左到右取模，看看最后的结果是否为零，如果不为0那就输出YES否则输出NO，题目主要就是取模运算，我们可以想想取模运算有那些规律，首先a%b之后的值肯定小于b，我们可以先将数组排序，小的数模上大的数显然就等于小的数，所以我们可以一直利用这个最小数，最终的答案肯定也就是这个最小的数，但是会有一个问题，比如这个数出现了两次，这样的话他们模之后就会为0，那么关键就是怎么解决最小的数出现多次的情况，想出这个答案，题目就能得到解决，那么我们可以遍历数组中的数，只要a[i] % min != 0 那就能找到一个更小的min，然后一直用这个min来模其他的数，这样问题就得到了解决。
3. 思考如何解决题目，**用什么数据结构**，在发现规律的过程中要解决什么问题，解决了这些问题我们就能得出答案，实际上就是把**题目的本质**找出来了，看透题目想要考察我们什么，我们就能给出相应的对策。



# 常用代码模板1——基础算法

## 排序

### 快速排序

快速排序是基于分治的思想

- 1.先确定分界点，一般选取右边界，左边界或者中间点，但是其实可以选取任意一点

- 2.调整视图，将大于分界点的放在分界点右边，小于的放在左边

- 3.递归的处理左右两段

```c++
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return; //表示不可再分，左边界等于有边界
    int x = q[l + r >> 1], i = l - 1, j = r + 1;
    while (i < j) //注意要严格小于，因为当相遇的时候，下面会先做++
    {
        while (q[++i] < x); //注意要严格小于，因为当相遇的时候，下面会先做++
        while (q[--j] > x); //找到第一个小于等于q[i]的数
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j);
    quick_sort(q, j + 1, r);
}
```



有以下几个问题

**1.为什么判断递归结束的条件区间等于1时递归结束是要if(l>=r)**

> 不是区间开头吗，r区间结尾，当l=r时，区间长度为1，为什么要大于r呢

**2.为什么双指针要定义为区间头-1，区间尾+1，即 i = l -1，j=r+1，**

> 是为了满足do i ++；while(q[i]<x) 时，第一次i++刚好满足判定区间头的操作吗
> 我改为 i =l,j=r   while(q[i]<x) i++;    while(q[j]>x) j--;就TLE了

**3.递归时为什么要选择j作为变量递归 即quick_sort(l,j); quick_sort(j+1,l);**

> 不能选择i吗，因为我想的时每一次划分区间i跟j都重叠相遇了呀
> 不能勇quick_sort(l,i);  quick_sort(i+1,l);

第一个问题：
对于 l == r 在这里是可以的。

第二个问题：
while(q[i]<x) i＋＋ ;
因为这里是先判断后 + 1，当q[i] == x == q[j]，且 i < j 时，q[i] 与 q[j] 交换之后，其实本质时并没有变化的，但是此时你的while循环会不断重复上述操作，导致你的 i 不会继续+ 1，同理你的 j 也不会 - 1，这段while语句永远在死循环，TLE时必然的。
而while (q[ ＋＋i ]<x) ;可以保证 i 会继续向后遍历，j 同理 。

第三个问题：
快排的原理是将左边划分为小于等于 x 的元素，右边划分为大于等于 x 的元素。a[i] 是一定大于等于 x 的，你把a[i]划到左边，可能使左边序列存在大于 x 的元素，并不能保证左边元素均小于等于 x，这样就违背了快排的原理。即使是quick_sort(l, i - 1), quick_sort(i, r)也是不行的，第一点 i-1 可能导致负数，RE；第二点，当 i == j == l 时，(i, r) 就是 (l, r)，相当于你返回了上一层递归，在一定条件下会导致上层递归进入下一层，下一层递归再返回到上一层这样的死循环，TLE。

> 举个例子,一开始 1 10 9 3 4 5 6 7 8
>
> 一开始j慢慢指向5，然后i指向10，交换，现在变成1 5 9 3 4 10 7 8
>
> 继续指向i指向9，j指向4，交换 ，现在变成1 5 4 3 9 10 7 8
>
> 最后i指向9，j指向3，这个时候保证了j左边一定是小的，i右边一定是大的，所以取右边界为j而不是i



### 归并排序

- 1.跟快速排序类似，还是先确定一个分界点，但是此分界点必须是中点
- 2.递归排序left和right，先递归的原因是要把区间分割成长度为一，然后再两两合并
- 3.不断递归然后归并，合二为一

```c++
void merge_sort(int q[],int l,int r){
  if(l >= r) return;

  int mid = l + r >> 1;
  merge_sort(q,l,mid);
  merge_sort(q,mid+1,r);//不断划分区间，直到区间的长度为1

  int k = 0,i = l,j = mid + 1;//相邻两项两两比较
  while(i <= mid && j <=r){
    if(q[i] <= q[j]) tmp[k++] = q[i++];
    else tmp[k++] = q[j++];
  }

  while(i <= mid) tmp[k++] = q[i++];
  while(j <= r) tmp[k++] = q[j++];//因为归并后有序，如果还没有遍历到终点，后面一定比前面大
  for(int i = l,j=0;i <= r;i++,j++) q[i] = tmp[j];//每次都把更新后的数据放进去，从而使用的就是传递进去的新的数组，每次都进行归并排序，
    //注意，上面的i都是等于字母l,就是把这次的数据放进去，而不是从放进去
  
  }
```

对于时间复杂度

1.每一层归并的时间复杂度是O（n）

2.归并的层数最大为O（logn+1）



## 二分

### 整数二分算法

1.去mid = l + r >> 1不断二分区间

2.看题目要求，二分之后满足什么性质，可以定义一个check函数，如果简单的话就直接的while循环中写

3.判断check函数，然后更新区间

```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质,如果满足，则说明结果在[l,mid]之间，那么这时将r变为mid，继续在二分
        else l = mid + 1;//这是区间在[mid+1,r]之间，将l变为mid+1
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}

```

- l = mid的情况，mid必须加一，因为如果l = r - 1时，更新后mid = l，这样就会回到上次递归，死循环了
- 对于区间如何划分，可以直接画图辅助理解
- 二分一定有解，答案不一定有解，也就是说经过无数次二分后，一定会得到一个值，但这个值不一定是答案，所以要判断一下

>二分大于当前a[i].x 的第一个数 的下标怎么写

```c++
在C++中，如果你想要找到一个数组中第一个大于当前元素的值的下标，你可以使用二分查找算法。二分查找算法通常用于在有序数组中查找特定值的位置。如果你的数组是升序排列的，你可以修改算法来查找第一个大于当前元素的值的下标。

以下是一个使用二分查找来找到第一个大于当前元素下标的示例代码：

#include <iostream>
#include <vector>
#include <algorithm>

int binarySearchFirstGreater(vector<int>& arr, int key, int n) {
    int low = 0, high = n - 1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] > key) {
            // 如果中间元素大于key，那么第一个大于key的元素可能在mid的左边
            high = mid - 1;
        } else {
            // 如果中间元素小于等于key，那么第一个大于key的元素可能在mid的右边
            low = mid + 1;
        }
    }
    
    //如果x没有出现两次当最终情况的前一种情况一定是l = r a[l/r] = x的
    //此时还没有跳出循环，继续执行，判断为第二种情况，也就是low = mid + 1
    //如果x出现多次，当a[mid]= x的时候low一定会往第一个大于key的元素靠,最后又是前面那种情况
    // 当low > high时，low指向的是第一个大于key的元素的下标
    return low;
}

int main() {
    vector<int> arr = {1, 3, 5, 7, 9, 11, 13, 15};
    int key = 7;
    int n = arr.size();

    int index = binarySearchFirstGreater(arr, key, n);
    if (index < n) {
        cout << "第一个大于 " << key << " 的元素的下标是: " << index << endl;
    } else {
        cout << "数组中没有大于 " << key << " 的元素。" << endl;
    }

    return 0;
}
在这个例子中，binarySearchFirstGreater 函数接受一个数组 arr，一个键值 key 和数组的大小 n。它使用二分查找来找到第一个大于 key 的元素的下标。如果数组中没有大于 key 的元素，low 将大于 high，此时 low 将指向数组的末尾，表示没有找到大于 key 的元素。
```

// 当low > high时，low指向的是第一个大于key的元素的下标这个是为什么，你能解释一下吗，最好加几个例子

> 当二分查找算法用于查找第一个大于给定键值的元素时，`low` 和 `high` 是指向数组的索引。在每次迭代中，我们根据中间元素与键值的比较结果来调整搜索范围。
>
> 1. 如果中间元素 `arr[mid]` 大于键值 `key`，那么我们知道第一个大于 `key` 的元素不可能在 `arr[mid]` 的右边，因为数组是有序的。所以，我们移动 `high` 到 `mid - 1`，缩小搜索范围到 `low` 和 `high` 之间。
> 2. 如果中间元素 `arr[mid]` 小于或等于键值 `key`，那么第一个大于 `key` 的元素可能在 `arr[mid]` 的右边。因此，我们移动 `low` 到 `mid + 1`，同样缩小搜索范围。
>
> 这个循环会一直进行，直到 `low` 超过 `high`。当 `low` 超过 `high` 时，`low` 的值实际上是最后一个小于或等于 `key` 的元素的下标加一。由于数组是有序的，所以 `low` 的下一个位置（即 `low + 1`）将是第一个大于 `key` 的元素的下标。
>
> 让我们通过几个例子来解释这个过程：
>
> 例子1： 数组：[1, 3, 5, 7, 9, 11, 13, 15] 键值：7
>
> - 初始化 `low = 0`, `high = 7`。
> - `low = 0`, `high = 7`, `mid = 3`, `arr[mid] = 5`（小于 `key`），`low = 4`。
> - `low = 4`, `high = 7`, `mid = 5`, `arr[mid] = 9`（大于 `key`），`high = 4`。
> - `low = 5`, `high = 4`, `low` 超过 `high`，循环结束。
>
> 此时 `low` 的值是 `5`，所以第一个大于 `key`（7）的元素的下标是 `5`。
>
> 例子2： 数组：[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 键值：6
>
> - 初始化 `low = 0`, `high = 9`。
> - `low = 0`, `high = 9`, `mid = 4`, `arr[mid] = 5`（小于 `key`），`low = 5`。
> - `low = 5`, `high = 9`, `mid = 7`, `arr[mid] = 8`（大于 `key`），`high = 6`。
> - `low = 7`, `high = 6`, `low` 超过 `high`，循环结束。
>
> 此时 `low` 的值是 `7`，所以第一个大于 `key`（6）的元素的下标是 `7`。
>
> 在这两个例子中，当 `low` 超过 `high` 时，`low` 的值指向了数组中第一个大于 `key` 的元素的下标。这是因为在有序数组中，一旦 `low` 超过了 `high`，`low` 的位置就是最后一个小于或等于 `key` 的元素的下标加一。



```c++
    int find1(int a[],int x){
        int l = 1,r = n;
        while(l < r){
            int mid = l+r >> 1;
            if(a[mid] >= x) r = mid;
            else l = mid + 1;
        }
        return l;
    }
    //如果有多个x相等，找到第一个x
     int find2(int a[],int x){
        int l = 1,r = n;
        while(l < r){
            int mid = l+r+1 >> 1;
            if(a[mid] <= x) l = mid;
            else r = mid - 1;
        }
        return r;
    }
    //如果有多个x相等，找到最后一个x

```





### 浮点数二分算法模板

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求，这个精度往往要比题目精度高两位
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

- 为什么这次不用考虑更新边界的问题，因为浮点数二分是求一个精度，而整数二分是在一个数组里面，边界可能会影响取值，而浮点数二分就不用太过关注



## 三分

类似与一个二次函数，有一个顶点，顶点左右两边都是单调的，就可以用三分找出顶点的值

<[算法竞赛2.4-三分法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Xg4y1u7au/?spm_id_from=333.337.search-card.all.click&vd_source=e03b7d988550b29e55118b7d8e6cab3c)>

1. 在[l,r]上任取2个点，mid1和mid2,把函数分成三段。
   (1)若f(mid1)<f(mid2),极值点v一定在mid1的右侧。此时，
   mid1和mid2要么都在v的左侧，要么分别在v的两侧。下一步，令l = mid1,区间从[l,r]缩小为[mid,r]，然后继续把它分成三段
2. 若f(mid1) > f(mid2) ,极值点v一定在mid2的左侧。下一步，令r = mid2,区间从[l,r]缩小为[l,mid2]
3. 三等分：mid1和mid2为[l,r]的三等分点。那么区间每次可以减少三分之一

例题<[Problem - E - Codeforces](https://codeforces.com/contest/1933/problem/E)>

也可以用二分参考<[Codeforces Round 929(边做边讲A-E)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1yS421N7h2/?spm_id_from=333.337.search-card.all.click&vd_source=e03b7d988550b29e55118b7d8e6cab3c)>

```c++
#include<iostream>
#include<queue>
#include<cstring>
#include<map>
#include<algorithm>
#include<vector>
#include<set>
#include<cmath>
#include<stack>
#include<random>
#include<ctime>
//#define ll long long
#define ull unsigned long long 
#define pb push_back
#define fi first
#define se second
#define ios ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
#define __int128_t int128
using namespace std;
// typedef pair<int, int> PII;
// typedef pair<ll, int> PLI;
int dx[4] = {-1,0,1,0},dy[4] = {0,1,0,-1};

const int MAX = 2e5 + 10;
int a[MAX];
int pre[MAX];
#define int long long

int f(int l,int r,int u){
    int section = pre[r] - pre[l-1];
    return (2*u+1 -section)*section / 2; // 除以 2 是必要的
}

void solve(){
    int n;
    cin >> n;
    pre[0] = 0;
    for(int i = 1; i<= n;i++) {
        cin >> a[i];
        pre[i] = pre[i-1] + a[i];
    }
    int q;
    cin >> q;
    while(q--){
        int L,u;
        cin >> L >> u;
        
        int l = L,r = n;
        while(l < r){
            int lmid = l + (r-l)/3; // 修正了 lmid 的计算
            int rmid = r - (r-l)/3; // 修正了 rmid 的计算
            if(f(L,lmid,u) < f(L,rmid,u)) l = lmid + 1;
            else r = rmid - 1;
        }
        cout << l  << " ";
    }
    cout << endl;
}
signed main(){
    ios;
    int t;
    cin >> t;
    while(t--){
        solve();
    }
}
```



## 高精度

### 高精度加法

- 主要思想就是模拟人做加法，需要有一个进位，还有一个注意的地方就是要把字符串从后往前存，因为有一个进位，如果你的首位是最大的要进位的话需要把数组里的元素全部往后移动，比较麻烦

- 主要思想就是每个一位等于C[i] = A[i] + B[i] + t

  ```c++
  // C = A + B, A >= 0, B >= 0
  vector<int> add(vector<int> &A, vector<int> &B)
  {
      if (A.size() < B.size()) return add(B, A);
  
      vector<int> C;
      int t = 0;
      for (int i = 0; i < A.size(); i ++ )
      {
          t += A[i];
          if (i < B.size()) t += B[i];
          C.push_back(t % 10);
          t /= 10;
      }
  
      if (t) C.push_back(t);
      return C;
  }
  
  ```

  

### 高精度减法

  ```c++
  vector<int> sub(vector<int> &A, vector<int> &B)
  {   //要保证A一定要大于B
      vector<int> C;
      for (int i = 0, t = 0; i < A.size(); i ++ )
      {
          t = A[i] - t;//先减去进位
          if (i < B.size()) t -= B[i];//判断一下，B够不够位数，不够的话就不进行对B的操作
          C.push_back((t + 10) % 10);//这个语句包含两种情况，t小于0和t大于0的时候都满足这个条件
          if (t < 0) t = 1;
          else t = 0;
      }
  
      while (C.size() > 1 && C.back() == 0) C.pop_back();//去掉前面为零的情况，如123-120=003
      return C;
  }
  ```


### 高精度乘法

- 跟高精度加法很类似，不过此时要把b看成一个整体，然后把A拆成每一个位数与b相乘,不像加法是一位一位相加放进数组

  ```c++
  // C = A * b, A >= 0, b >= 0
  vector<int> mul(vector<int> &A, int b)
  {
      vector<int> C;
  
      int t = 0;
      for (int i = 0; i < A.size() || t; i ++ )//如果t为0了可以提前结束判断
      {
          if (i < A.size()) t += A[i] * b;
          C.push_back(t % 10);//低于10的会被写出，高于10的会进位
          t /= 10;
      }
  
      while (C.size() > 1 && C.back() == 0) C.pop_back();
  
      return C;
  }
  ```

> 对于 i < A.size() || t的解释
>
> - 在循环内部的判断条件 i < A.size() || t 中，i < A.size() 表示 A 还有未处理的位数；而 t != 0 则表示进位仍然有值，即当前位的相乘结果需要加上上一位的进位值。也就是处理最后一位用的
>
>   当 for 循环结束后，数组 C 中可能存在末尾的0，需要使用 while 循环将末尾的0全部删除，得到最终的结果。



### 高精度除法

#### 高精度除以低精度

```c++
#include <bits/stdc++.h>
using namespace std;

int n;
int a[1010];
int minNum = 0;
int maxNum = 10000;
int main() {
    cin.tie(0);
    ios::sync_with_stdio(false);

    string s; // s是高精度的，比如1234567890123456789012345678901234567890
    int a; // a是低精度的，比如2024
    cin >> s >> a;
    
    int result[500] = { 0 }, num[500] = { 0 }; // num数组以int形式存放s的每一位，result数组存储运算的结果
    int rest = 0; // rest是余数
    for (int i = 0; i < s.length(); i++) num[i] = s[i] - '0';
    for (int i = 0; i < s.length(); i++) {
        rest = rest * 10 + num[i];
        result[i] = rest / a;
        rest %= a;
    }
    int i = 0;
    while (result[i] == 0 && i < s.length()) i++;
    cout << "the result is: ";
    for (; i < s.length(); i++) cout << result[i];
    cout << endl;
    cout << "the rest is:" << rest;

    return 0;
}
```



#### 高精度除以高精度

```c++
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```



>注意此时需要从高位开始计算，因为高精度除法是先看高位，不像加减乘从低位计算起看看有没有进位或者借位



## 前缀和与差分

### 一维前缀和

```c++
//前缀和就是将该数及之前的所有数都求和，即sum[i]=sum[1]+sum[2]+...+sum[i].相当于数列的前n项和Sn。
//区间和即为右端点到开头的总和减去左端点前一个数到开头的总和，这样就求出了这个区间内的数的总和

/*开辟sum数组存粹是为了不想破坏原数组，如果可以破坏原数组其实可以不用开个sum，直接
for(i=1;i<n;i++) q[i]+=q[i-1]就行了*/
/*此处为求原数组中[l,r]的和*/
#include <iostream>
using namespace std;

int n, m;
int q[1000010], sum[1000010];

int prefix_sum(int l, int r)
{
	return sum[r] - sum[l - 1];
}

int main()
{
	cin >> n >>m;
	int res;
	int i;
	for (i = 1; i <= n; i++) cin >> q[i];
	
	sum[1] = q[1];
	for (int i = 1; i < n; i++) sum[i] = sum[i - 1] + q[i];

	int l, r;
	while (m--) {
		cin >> l >> r;
		res = prefix_sum(l, r);
		cout << res << endl;
	}

	return 0;
}
```

- 前缀和就是一种时间换空间的算法，把每一个和放到数组中可以，求区间[l,r]的和可以达到O（1）的时间复杂度

- 注意S[0]=0，故循环一般从1开始，方便统一化

- 积分思想

  



### 子矩阵（二维）的前缀和

![1705418670414](C:\Users\肖翰\Downloads\typora\1705418670414.png)



```c++
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1] 
    
//二维前缀和求的是两个坐标围成的矩阵内的数字之和
//思想和一维前缀和差不多，都是大减小
//其实如果题目允许的话，可以将sum[]建得比q[]大一，然后从[1,1]开始输入原数组，就不用进行那么多的
//特判了，求前缀和只需要一条式子，求答案也是只要一条式子。
//但是有些题目不允许多开一行和一列，这时我们只能老老实实地进行特判
//无论怎么说，下列程序是万能的

#include <iostream>
using namespace std;

int n, m;
int q[10010][10010], sum[10010][10010];
void prefix_sum(void);
int get_ans(int x1, int y1, int x2, int y2);

int main()
{
	int cnt;
	cin >> n >> m >> cnt;
	int i, j;
	for (i = 0; i < n; i++) {
		for (j = 0; j < m; j++) {
			cin >> q[i][j];
		}
	}
	prefix_sum();
	int x1, y1, x2, y2;
	while (cnt--)
	{
		cin >> x1 >> y1 >> x2 >> y2;
		int ans = get_ans(x1, y1, x2, y2);
		cout << ans << endl;
	}

	return 0;
}

void prefix_sum(void) 
{
	sum[0][0] = q[0][0];
	int i, j;
	for (i = 1; i < n; i++) sum[i][0] = sum[i - 1][0] + q[i][0];
	for (j = 1; j < m; j++) sum[0][j] = sum[0][j - 1] + q[0][j];
	for (i = 1; i < n; i++) {
		for (j = 1; j < m; j++) {
			sum[i][j] = q[i][j] + sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];
		}
	}
}

int get_ans(int x1, int y1, int x2, int y2)
{
	int ans;
	if (!x1 && !y1) ans = sum[x2][y2];
	else if (!x1 && y1) ans = sum[x2][y2] - sum[x2][y1 - 1];
	else if (x1 && !y1) ans = sum[x2][y2] - sum[x1 - 1][y2];
	else ans = sum[x2][y2] - sum[x2][y1 - 1] - sum[x1 - 1][y2] + sum[x1 - 1][y1 - 1];

	return ans;
}
```

- 作用跟前缀和同理，具体细节可以画图以便理解

- 坐标可以理解为每一个方形的右下角

  

### 一维差分

``` c++
//适用背景：给定一个长度为n的数组，进行m次操作，每次将数组下标在[l,r]内的数的值改变value
//问全部操作完成后该数组将变成什么样

#include <iostream>
using namespace std;

int q[1000010]; // 原数组
int d[1000010] = { 0 }; // 差分数组
void difference(int l, int r, int value); // 打上差分标记

int main()
{
	int n, m;
	cin >> n >> m;
	int l, r, value;
	int i;
	for (i = 0; i < n; i++) {
		cin >> q[i]; // 输入数组
	}
	while (m--) {
		cin >> l >> r >> value;
		difference(l, r, value); // 打上差分标记
	}
	for (i = 1; i < n; i++) {
		d[i]  += d[i - 1];      //OMG差分标记完后千万别忘记对差分数组求前缀和呀！！！求前缀和才能将刚刚打上的差分标记扩散开来！
	}

	for (i = 0; i < n; i++) {
		q[i] += d[i]; // 对原数组进行改变，每个下标都加上要改变的值（即差分数组中记录的值）
	}
	for (i = 0; i < n; i++) {
		cout << q[i] << ' '; // 输出改变后的数组
	}

	return 0;
}

void difference(int l, int r, int value)
{
	d[l] += value; // 从l开始向后，每个元素都要加value
	d[r + 1] -= value; // 由于只在l和r之间改变，所以要抵消r后的，所以在r+1开始要减去value以抵消其影响
}
```

- 在区间[l,r]加上一个数可以达到O（1）的时间复杂度
- 微分思想



### 二维差分

```c++
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c(这个是因为加了两次要减去重复的)
```



```c++
//二维差分与一维差分同理，打上标记后再求前缀和将影响传递给后面的数字，只不过是按面扩散，所以要进行三次标记以清除对不相干的数的影响，再和原数组加起来就行了

#include <iostream>
using namespace std;

int n, m;
int q[10010][10010]; // 原数组
int d[10010][10010] = { 0 }; // 差分数组
void difference(int x1, int y1, int x2, int y2, int value);
void pre_fix(void);
void trans(void);

int main()
{
	int cnt;
	cin >> n >> m >> cnt;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cin >> q[i][j];
		}
	}
	int x1, y1, x2, y2, value;
	while (cnt--)
	{
		cin >> x1 >> y1 >> x2 >> y2 >>value;
		difference(x1, y1, x2, y2, value);
	}
	pre_fix();
	trans();
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < m; j++) {
			cout << q[i][j] << ' ';
		}
		cout << endl;
	}

	return 0;
}

void difference(int x1, int y1, int x2, int y2, int value)
{
	d[x1][y1] += value;
	d[x2 + 1][y1] -= value;
	d[x1][y2 + 1] -= value;
	d[x2 + 1][y2 + 1] += value;
}

void pre_fix(void)
{
	int i, j;
	for (i = 1; i < n; i++) d[i][0] += d[i - 1][0];
	for (j = 1; j < m; j++) d[0][j] += d[0][j - 1];
	for (i = 1; i < n; i++) {
		for (j = 1; j < m; j++) {
			d[i][j] = d[i][j] + d[i - 1][j] + d[i][j - 1] - d[i - 1][j - 1];
		}
	}
}

void trans(void) {
	int i, j;
	for (i = 0; i < n; i++) {
		for (j = 0; j < m; j++) {
			q[i][j] += d[i][j];
		}
	}
}
```



> <[798. 差分矩阵 - AcWing题库](https://www.acwing.com/problem/content/800/)>

```c++
#include<bits/stdc++.h>
using namespace std;
#define N 1005

int a[N][N];
int s[N][N];

void insert(int x1,int y1,int x2,int y2,int c){
    s[x1][y1] += c;
    s[x1][y2+1] -= c;
    s[x2+1][y1] -=c;
    s[x2+1][y2+1] +=c;
}


int main(){
    int n,m,q;
    cin >> n >> m >> q;
    for(int i= 1;i<=n;i++){
        for(int j = 1;j<=m;j++){
            cin >> a[i][j];
        }
    }
    for(int i = 1;i<=n;i++){
        for(int j = 1;j<=m;j++){
            insert(i,j,i,j,a[i][j]);
        }
    }
    while(q--){
        int x1,y1,x2,y2,c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1,y1,x2,y2,c);

    }
    for(int i= 1;i<=n;i++){
        for(int j = 1;j<=m;j++){
            a[i][j] = a[i-1][j] + a[i][j-1] - a[i-1][j-1] + s[i][j];//二维矩阵的前缀和
        }
    }
    for(int i = 1;i<=n;i++){
        for(int j = 1;j<=m;j++){
            cout << a[i][j] << " ";
            }
            cout << endl;
    }
}

```





## 双指针算法

双指针算法的核心思想是将时间复杂度为O(n^2)的朴素算法（双重循环）优化到O(n)，因为无论是i还是j，都只会增加不会减小，而且最多都只加到n，所以i和j最多一起加2n次，所以时间复杂度为O(n)。

```c++
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```

- 双指针的作用：可以把O(n^2)的时间复杂度变为O（n）
- 一般先用暴力解法思考，然后注意i和j之间的联系



例：从给定的字符串中分隔出单词，每个单词之间用空格隔开且开头不是空格。如：输入abc def ghi 输出abc回车def回车ghi。

```c++
#include <bits/stdc++.h>
using namespace std;

int main()
{
	string s;
	getline(cin, s);

	for (int i = 0; i < s.length(); i++) { // i从开头一直往后遍历直到结束
		int j = i; // j初始化为i，即以i的位置为起点
		while (j < s.length() && s[j] != ' ') j++; // 只要j没有遍历完整个字符串而且j所指的是字母而非空格，则j向后走，直到j指的是空格

		// 每道题目的具体逻辑，此处i至j-1之间的就是单词，所以输出它们
		for (int k = i; k < j; k++) cout << s[k];
		cout << endl;

		i = j; // 将i指向j的位置，直接跨越了中间的单词
	}


	return 0;
}
```



最长不重复连续子序列，如1 2 2 3 5 ，最长不重复连续子序列的个数为3（该序列为2 3 5）。

```c++
// 注意，本题数据很小，数据量也很小，所以才能这样写。如果数据量和数据很大的话，可以用哈希表做
#include <bits/stdc++.h>
using namespace std;

int n;
const int N = 1000010;
int a[N], num[N]; // a数组存储输入的序列，num数组存储每个数字出现的个数

int main()
{
	cin >> n;
	for (int i = 0; i < n; i++) cin >> a[i];

	int res = 0;
	for (int i = 0, j = 0; i < n; i++) {
		num[a[i]]++; // i每次向右走，就相当于该数出现了一次
		while (num[a[i]] > 1) // 如果a[i]出现的次数大于1了，也就是第二次一定是新加进来的a[i]
		{
			num[a[j]]--; // 一直剔除j，直到a[i]出现的次数为1
			j++;
		}
		res = max(res, i - j + 1); // 答案
	}

	cout << res;

	return 0;
}
```





## 位运算

求一个十进制数n的二进制表示中第k位是几（注意，二进制中最右边的是第0位）：

1. 先把第k位移到最后一位（右移到个位）：n >> k
2. 看个位是几：x & 1

将以上两个步骤合二为一，就得到了一个常用公式：`n >> k & 1`。



求一个数的二进制表示：先算出该数的二进制一共有几位（自己手算），然后从最高位至第0位依次让n右移那么多位再与上1，所以即使二进制中该位的数。

如十进制10，求其二进制表示

```c++
#include <iostream>
using namespace std;

int main()
{
	int n = 10;
    // k等于3是因为我们自己知道10的二进制表示中共有4位数字
	for (int k = 3; k >= 0; k--) cout << (n >> k & 1);

	return 0;
}
```



**lowbit运算**：

lowbit(x)：返回x的最后一位1，且返回的是二进制数，该数字1的后面只有0或者什么都没有。比如当x等于1010，lowbit(x)返回10，当x等于1010000，lowbit(x)返回10000。

实现方法：直接x&-x即可。

原理：负数在计算机中是以补码的形式存在的，也就是x取反再加1，所以x&-x = x&(~x+1)。于是-x实际上与x相比，除了最右边一个1及其右边的0不变外，左边都是完全相反的，此时再与上x，就得到了x的最右边的一个1及其右边的0。

<img src="D:\My tepora note\算法.assets\image-20240310162201813.png" alt="image-20240310162201813" style="zoom: 40%;" />

用途：可以用它求出一个数的二进制表示有多少个1。只需要在一个循环中，只要数字x大于0，就每次减去它的最右边的1。当x为0跳出循环了，一共减了多少次，就是数字x的二进制表示中1的个数。

例：求输入n个数中每个数的二进制中有多少个1，如输入5个数1 2 3 4 5，输出 1 1 2 1 2

```c++
#include <iostream>
using namespace std;

int lowbit(int x)
{
	return x & -x;
}

int main()
{
	int n;
	cin >> n;
	while (n--)
	{
		int x;
		cin >> x;
		int cnt = 0;
		while (x) x -= lowbit(x), cnt++; // 每次减去最右边的1
		cout << cnt << ' ';
	}

	return 0;
}
```



## 离散化

[C++STL中的unique函数解析 - Excaliburer - 博客园 (cnblogs.com)](https://www.cnblogs.com/wangkundentisy/p/9033782.html)

```c++
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}

```

>模板题—— <[AcWing 802. 画个图辅助理解~ AcWing](https://www.acwing.com/solution/content/13511/)>

- 把数字映射到下标，利用哈希的思想

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
const int N = 300010; //n次插入和m次查询相关数据量的上界
int n, m;
int a[N];//存储坐标插入的值
int s[N];//存储数组a的前缀和
vector<int> alls;  //存储（所有与插入和查询有关的）坐标
vector<pair<int, int>> add, query; //存储插入和询问操作的数据

int find(int x) { //返回的是输入的坐标的离散化下标
    int l = 0, r = alls.size() - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        int x, c;
        scanf("%d%d", &x, &c);
        add.push_back({x, c});
        alls.push_back(x);
    }
    for (int i = 1; i <= m; i++) {
        int l , r;
        scanf("%d%d", &l, &r);
        query.push_back({l, r});
        alls.push_back(l);
        alls.push_back(r);
    }
   //排序，去重
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(), alls.end()), alls.end());
    //执行前n次插入操作
    for (auto item : add) {
        int x = find(item.first);
        a[x] += item.second;
    }
    //前缀和
    for (int i = 1; i <= alls.size(); i++) s[i] = s[i-1] + a[i];
    //处理后m次询问操作
    for (auto item : query) {
        int l = find(item.first);
        int r = find(item.second);
        printf("%d\n", s[r] - s[l-1]);
    }

    return 0;
}

```





## 区间合并

```c++
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;//开始将区间划分在负无穷
    for (auto seg : segs)
        if (ed < seg.first)//如果这个维护的区间小于当前区间的右端点，就放到res中
        {
            if (st != -2e9) res.push_back({st, ed});//初始这个区间不能放进去
            st = seg.first, ed = seg.second;//更新成新的区间，后面对这个区间比较（维护区间）
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});//没有输入的情况

    segs = res;
}


```

- 第一步先将左端点按顺序排序
- 遍历每一个区间，如果新的区间的左端点小于原来区间的右端点，更新区间
- 否则说明两个区间不相交，加入到答案中去



# 常用代码模板2——数据结构

## 链表与邻接表：树与图的存储

### 单链表

用数组模拟链表实现，好处：链表每一次new（）的动态分配需要花费很多时间，用数组实现能大大提高效率

单链表的作用：存储图和树,对于数据的插入和删除。

<[数组模拟单链表你会了吗？ - 时间最考验人 - 博客园 (cnblogs.com)](https://www.cnblogs.com/lwtyyds/p/15490728.html)>

```c++
// head存储链表头(我的理解是头节点的指向)，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;//-1表示头节点指向空
    idx = 0;
}

// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}
```

> <[826. 单链表 - AcWing题库](https://www.acwing.com/problem/content/828/)>

```c++
#include<bits/c++io.h>
#include<iostream>
using namespace std;

#define N 100005
int e[N],ne[N];
int head,idx;

// head 表示头结点的指向，e数组存储元素，ne数组存储下一个节点索引，
// indx表示下一个可以存储元素的位置索引。
// 可以把idx看成new的一个最新节点，ne[idx]表示idx指针的指向

void init(){
    head = -1;//-1表示取不到的点，即表示为空
    idx = 0;
}

void add_to_head(int x){
    e[idx] = x;//先把x这个值保存下来
    ne[idx] = head;//此节点指向头指针指向的元素
    head = idx;//更新头指针的指向
    idx++;
}

void add(int k,int x){
    e[idx] = x,ne[idx] = ne[k],ne[k] = idx,idx++;
}

void remove(int k){
    ne[k] = ne[ne[k]];//将第k个节点的指针指向下下个指针
    //每次删除后这个点的元素的ne[i] = -1,也就是指向空
}

int main(){
    int m;
    init();
    cin >> m;
    while(m--){
        char op;
        int k,x;
        cin >> op;
        if(op == 'H'){
            cin >> x;
            add_to_head(x);
        }else if(op == 'D'){
            cin >> k;
            if(!k) head = ne[head];
            else remove(k-1);//第k个元素对应的索引为k - 1
        }
        else {
            cin >> k >> x;
            add(k-1,x);
        }
    }
    for(int i = head;i != -1;i = ne[i]){
        cout << e[i] << " ";
    }
    cout << endl;
}
```

例题<[C - Lining Up 2 (atcoder.jp)](https://atcoder.jp/contests/abc337/tasks/abc337_c)>

<[D-小红数组操作_牛客周赛 Round 31 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/74362/D)>

### 双链表

找节点可以是$O(1)$的操作，因为每一个节点都被放在了数组中

比如你想要找整数5的左右节点，那么就是r[5]和l[5]

```c++
//e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N],l[N],r[N],idx;

//初始化
void init(){
//0是左端点，1是右端点
r[0] = 1,l[1] = 0;
idx = 2;
}

//在节点a的右边插入一个数
void insert(int a,int x){
e[idx] = x;
l[idx] = a;
r[idx] = r[a];
l[r[a]] = idx,r[a] = idx++;//l[r[a]]表示a节点右边那个节点的左边的指向
}

//删除节点a
void remove(int a){
l[r[a]] = l[a];
r[l[a]] = r[a];
}
```

例题<[D-小红数组操作_牛客周赛 Round 31 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/74362/D)>

完整代码

```c++
#include<iostream>
#include<vector>
vector<int> ans;

int main(){
	ios;
	int q;
	map<int, int> l, r;
    r[0] = 1e9 + 1;//表示起点
    l[1e9 + 1] = 0;//表示终点，画一个图就很好表示
	cin >> q;
	while(q--){
		int op;
		cin >> op;
		
		if(op == 1){
			int x,y;
			cin >> x >> y;
			r[x] = r[y];
			l[r[y]] = x;
			l[x] = y;
			r[y] = x;
            //代码理解有难度就画一个图，非常好理解
            //就是普通的链表操作
		}else {
			int x;
			cin >> x;
			r[l[x]] = r[x];
			l[r[x]] = l[x];
		}
	}
	int x = 0;
	while(true){
		x = r[x];
		if(x == 1e9+1) break;
		ans.push_back(x);
	}
	cout << ans.size() << endl;
	for(auto x: ans) cout << x << ' ';
	cout << endl;
	return 0;
}
```



## 栈与队列：单调队列、单调栈

### 栈

```c++
//tt表示栈顶
int stk[N],tt = 0;

//向栈顶插入一个元素
stk[++tt] = x;

//从栈顶弹出一个元素
tt--;

//栈顶的值
stk[tt];

//判断栈是否为空，如果tt > 0,则表示不为空
if(tt > 0){
}
```

### 普通队列

```c++
//hh 表示队头，tt表示队尾
int q[N],hh = 0,tt = -1;//y总习惯将队头初始化为0，队尾初始化为-1

//向队尾插入一个数
q[++tt] = x;

/从队头弹出一个数
hh++;

//队头的值
q[hh];

//判断队列是否为空，如果 hh <= tt,则表示不为空
if(hh <= tt){
}
```

滑动窗口单调队列解题步骤

1. 首先需要定义一个双端队列deque来维护单调性，怎么维护呢？比如要求一个滑动窗口中的最小值，我们希望队头是最小的元素，这个时候我们就要维护队列要为非递减的，那就有while(!q.empty()&&q[q.back()] < a[i]) q.pop_back();然后再把元素push_back队尾中
2. 还需要维护滑动窗口中元素的个数，怎么维护呢？只要i（当前的元素下标）- k 超过了队头元素也就是最小值的下标，那就说明这个队头元素不在这个滑动窗口里面，就pop_front，接着就是输出元素了

```c++

#include <iostream>
#include <deque>
using namespace std;
#define ios ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);
const int N = 1e6 + 10;

int n, k;
int a[N];
deque<int> q;

int main() {
    ios;
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= n; i++) {
        // 保持窗口为非递增，队首是窗口最小值
        while (!q.empty() && a[q.back()] > a[i]) {
            q.pop_back(); // 移除比当前元素大的队尾元素
        }
        
        q.push_back(i); // 将当前元素索引加入队列
        
        // 当窗口滑动超出队首元素时，移除队首元素
        if (i - k >= q.front()) {
            q.pop_front();
        }
        
        // 从窗口完全包含k个元素开始输出
        if (i >= k) {
            cout << a[q.front()] << " "; // 输出窗口的最小值
        }
    }
    q.clear();
    cout << endl;
    for(int i = 1;i <= n;i++){
    	//维护队列的单调性，队列中是单调非递增的，窗口最大值是队首元素
    	while(!q.empty()&& a[q.back()] < a[i]) q.pop_back();
    	
    	q.push_back(i);
    	
    	//维护队列的数量
    	if(i - k >= q.front()){
    		q.pop_front();
    	}
    	//前k-1次是将元素加入进来，第k次开始每一次滑动都会输出一个数字
    	if(i >= k){
    		cout << a[q.front()] << " ";
    	}
    }
    
    return 0;
}
```



### 单调栈

原理分析：这需要借助数据结构栈，以左边比它小的为例，每次往后遍历，跟栈顶元素比较（栈顶元素应该是栈中最小的）判断是否比栈顶元素小，如果比栈顶元素小，那么就入栈，这样就能得到左边离他最近的比它小的数，这一定是最小的，不是最小的会被栈顶元素挡住，同时也一定是最近的，因为这是数据结构栈。

一开始可以从暴力的想法做，然后再想想怎么优化暴力写法;int main(){



```
常见模型：找出每个数左边离他最近比它大/小的数
int tt = 0;
for(int i= 1;i <= n;i++){
while(tt && check(stk[tt],i)) tt--;
stk[++tt] = i;//stk表示栈
}

//例如找出左边离他最近比它小的数
int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        while (tt && stk[tt] >= x) tt -- ;//如果栈顶元素大于当前待入栈元素，则出栈
        if (!tt) printf("-1 ");//如果栈空，则没有比该元素小的值。
        else printf("%d ", stk[tt]);//栈顶元素就是左侧第一个比它小的元素。
        stk[ ++ tt] = x;
    }
    return 0;
}

```

### 单调队列滑动窗口最值

队尾进队出队，队头出队（维护子序列的单调性）

1. 队尾出队的条件：队列不空且新元素更优，队中旧元素队尾出队
2. 每个元素必然从队尾进队一次
3. 队头出队的条件：队头元素滑出了窗口

注意：队列中存储元素的下标，方便判断队头出队

```c++
//维护窗口最小值,队头就是最小值
int h = 1,t = 0;//head表示队头，tail表示队尾
for(int i = 1; i <= n;i++){//枚举队列
	while(h <= t&& a[q[t]] >= a[i])  t--;//队尾出队（队列不空，并且新元素更优）
	q[++t] = i;//队尾入队（存储下标，方便判断队头出队）
	if(q[h] < i-k+1) h++;//队头出队（区间大于窗口长度）
	if(i >= k) printf("%d ",a[q[h]]);//输出最值
	
}
```





### 循环队列

```c++
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空，如果hh != tt，则表示不为空
if (hh != tt)
{

}
//其实就是比普通队列多加了一个判断，如果队头满了，那么就回到起点，弹出元素也是一样的
```

### 滑动窗口

思想类似与单调栈，需要维护单调性

```c++
#include <iostream>
using namespace std;
const int N = 1e6+10;
int n,k;
int a[N],q[N];//队列q不是滑动窗口！只是在实际窗口向右滑动时维护的一个单调队列。队列q的放置方式：hh队头在左端，tt队尾在右端
int hh,tt=-1;//hh初始化为-1和0结果都是一样的，没有影响
int main()
{
    cin >> n >> k;
    for(int i=0;i<n;i++) scanf("%d", &a[i]);

    //找窗口中的最小值
    for(int i=0;i<n;i++){
        //其中i表示滑动窗口的右端点位置，所以当前实际窗口的左端点位置应为i-k+1
        //而队列q[hh]存的则为窗口中数值最小的元素的位置，姑且记为pos，
        //则必有pos>=i-k+1，反之(即i-k+1>pos)，则pos位置已经从左边移出窗口，
        //而位置pos即为q[hh]，故若i-k+1>pos,则hh++；
        if(hh<=tt&&i-k+1>q[hh]) hh++;

        //若队尾元素的值a[q[tt]]>=滑动窗口的右端点a[i]，则为了维护队列q单调，需要删除队尾
        while(hh<=tt&&a[q[tt]]>=a[i]) tt--;
        //直到队尾元素比窗口右端点的值小a[q[tt]]<a[i]，将位置i入队
        q[++tt] = i;

        //窗口是从数组a中第一个元素a[0]开始吞入，故要等到窗口中的元素满了才可以输出。
        if(i>=k-1) printf("%d ",a[q[hh]]);
    }
    printf("\n");

    //找窗口中的最大值
    hh = 0, tt = -1;
    for(int i=0;i<n;i++){
        if(hh<=tt&&i-k+1>q[hh])hh++;
        while(hh<=tt&&a[q[tt]]<=a[i])tt--;//只需要修改这里的
        q[++tt]=i;
        if (i>=k -1)printf("%d ", a[q[hh]]);
    }

    return 0;
}

```

- 首先确保窗口大小不超过m,如果超过，弹出队头
- 更新结果
- 将队尾与此时的第i个元素作比较，如果队尾不满足条件，弹出
- 加入第i个元素

<[滑动窗口算法基本原理与实践 - huansky - 博客园 (cnblogs.com)](https://www.cnblogs.com/huansky/p/13488234.html)>

> 子串/子数组子序列
> 例如：长度最小的子数组
> 滑动窗使用思路（寻找最长）
> 核心：左右双指针(L,R)在起始点，R向右逐位滑动循环
> 一—每次滑动过程中
> 如果：窗内元素满足条件，R向右扩大窗口，并更新最优结果
> 如果：窗内元素不满足条件，L向右缩小窗口
> 一一R到达结尾
> 滑动窗使用思路（寻找最短）
> 核心：左右双指针(L,R)在起始点，R向右逐位滑动循环
> 每次滑动过程中
> 如果：窗内元素满足条件，L向右缩小窗口，并更新最优结果
> 如果：窗内元素不满足条件，R向右扩大窗口
> 一R到达结尾

```
//最长模板：
初始化left,right,result,bestResult
while(右指针没有到结尾){
	窗口扩大，加入right对应元素，更新当前result
	while(result不满足要求){
		窗口缩小，移除left对应元素,left右移
	}
	更新最优结果bestResult
	right++;
}
返回bestResult;

//最短模板：
初始化left,right,result,bestResult
while(右指针没有到结尾){
	窗口扩大，加入right对应元素，更新当前result
	while(result满足条件){
		更新最优结果bestResult
		窗口缩小，移除left对应元素，left右移
	}
	right++;
}
返回bestResult;
```



## kmp

- kmp我认为最重要的就是求next数组和匹配过程

### 一.匹配过程

```c++
//匹配过程
i表示文本串的的位置，j表示模板串的位置
for(int i = 1,j = 0;i <= n;i++){
while(j && s[i] != p[j+1]) j = ne[j];
//当j已经退无可退了，并且文本串第i个与模板串第j+1匹配失败，那么移动模板串，怎么移动又能避免次数多，又能确保结果正确呢，那就是找前缀相等的，也就是我i对应的j(包括j)到模板串的某一位置，能找到从开始出到j的某一位置相等（p[1,j] = p[i-j+1]），那么我就可以移动此位置
if(s[i] == p[j+1]) j++;//当前元素匹配，j移向p串下一位，因为每次只看一位匹不匹配，所以i不需要加
if(j == m){
//长度等于m的长度，说明匹配成功
j = next[j];//继续匹配下一个子串
}}
```

![如图](C:\Users\肖翰\Downloads\typora\1703681816969.png)



### 二.求next数组

```c++
//求next数组
for(int i= 2,j = 0;i<=m;i++){
while(j && p[i] != p[j+1]) j = next[j];
if(p[i] == p[j+1]) j++;
next[i] = j;//next[1]肯定等于0，一般数组初始化就是0，所以从二开始
}
```

![next数组](C:\Users\肖翰\Downloads\typora\31041_97225cdcac-next数组.png)

代码和匹配操作的代码几乎一样，关键在于每次移动 i 前，将 i 前面已经匹配的长度记录到next数组中。

### 三.完整代码

```c++
// 注：这不是题目的AC代码，是一个最基本的模板代码
#include <iostream>

using namespace std;

const int N = 100010, M = 10010; //N为模式串长度，M匹配串长度

int n, m;
int ne[M]; //next[]数组，避免和头文件next冲突
char s[N], p[M];  //s为模式串， p为匹配串

int main()
{
    cin >> n >> s+1 >> m >> p+1;  //下标从1开始

    //求next[]数组
    for(int i = 2, j = 0; i <= m; i++)
    {
        while(j && p[i] != p[j+1]) j = ne[j];
        if(p[i] == p[j+1]) j++;
        ne[i] = j;
    }
    //匹配操作
    for(int i = 1, j = 0; i <= n; i++)
    {
        while(j && s[i] != p[j+1]) j = ne[j];
        if(s[i] == p[j+1]) j++;
        if(j == m)  //满足匹配条件，打印开头下标, 从0开始
        {
            //匹配完成后的具体操作
            //如：输出以0开始的匹配子串的首字母下标
            //printf("%d ", i - m); (若从1开始，加1)
            j = ne[j];            //再次继续匹配
        }
    }

    return 0;
}

```



我自己的模板：

```c++
#include <iostream>
#include <string>
#include <vector>
using namespace std;

void get_Next(string p, vector<int>& Next);
int KMP_match(string s, string p, int begin);

int main()
{
	string s, p;
	cin >> s >> p;
	int num = KMP_match(s, p, 0);
	cout << num;
	system("pause");

	return 0;
}

void get_Next(string p, vector<int>& Next)
{
	for (int j = 0, i = 1; i < p.length(); i++) {
		while (j && p[j] != p[i]) j = Next[j - 1];
		if (p[i] == p[j]) j++;
		Next[i] = j;
	}
}

int KMP_match(string s, string p, int begin)
{
	int num = -1; //若没找到子串就返回-1
	vector<int> Next(p.length());
	get_Next(p, Next);
	for (int i = begin, j = 0; i < s.length(); i++) {
		while (j && s[i] != p[j]) j = Next[j - 1];
		if (s[i] == p[j]) j++;
		if (j == p.length()) {
			num = i - p.length() + 1;  //找到了就进行题目的要求，此处是返回子串在主串中的位置
			break;
		}
	}
	return num;
}
```



## Trie

**Trie 树有什么用？**

Trie 树又叫字典树。字典是用来查字的，Trie 树最基本的作用是在树上查找字符串。

例如有 5 个字符串： him 、 her 、 cat 、 no 、 nova 。现在要查找 catch 是否存在。

如果使用暴力的方法，需要用 catch 与这 5 个字符串分别进行匹配，效率较低。

如果将这 5 个字符串存储成 Trie 的结构，只需要顺着路径依次比较，比较完 cat 之后，没有节点与 c 匹配，所以字符串集合中不存在 catch。

```c++
int son[N][26],cnt[N],idx;
//0号点即是根节点，又是空节点
//son[][]存储树中每个节点的子节点，26包含了全部字母
//cnt[]存储以每个节点结尾的单词数量，相当于标记一下
//idx相当于一个节点，每有一个新节点就++，表示创建了一个新节点

//p可以看成是树的第几层，比如p=0就是第一层的元素，然后p=1，就是第二层的元素 2024.01.05

//插入一个字符串，
void insert(char *str){
int p = 0;//p一开始表示根节点为0
for(int i = 0;str[i];i++){
int u = str[i] - 'a';//将字母a~z映射要下标0-25
if(!son[p][u]) son[p][u] = ++idx;//没有路就直接创建一条路，如果已经有路就用这条路
p = son[p][u];//这个时候，p 等于字符串 s 的尾字符所对应的 idx
    //cnt[p] 保存的是字符串 s 出现的次数
    //故 cnt[p] ++
}
cnt[p]++;
}

//查询字符串出现的次数
int query(char *str){
int p = 0;
for(int i = 0;str[i];i++){
int u = str[i] - 'a';
if(!son[p][u]) return 0;
p = son[p][u];
return cnt[p];
}
}
```



## 并查集

**并查集的作用**：1.将两个集合合并

2.询问两个元素是否在一个集合当中

**基本原理**：每一个集合用一颗树来表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点

- 如何判断树根：if(p[x] == x)
- 如何求x的集合编号：while(p[x] != x) x = p[x];
- 如何合并两个集合，px是x的集合编号，py是y的集合编号，p[x] = y;

并查集最本质的就是求find函数



### 朴素并查集

```c++
(1)朴素并查集：
int p[N];//存储每个点的祖宗节点

//返回x的祖宗节点
int find(int x){
if(p[x] != x) p[x] = find(p[x]);//路径压缩
return p[x];
}

//初始化，假定节点标号是1~n
for(int i = 1;i <= n;i++) p[i] = i;

//合并a和b所在的两个集合:
p[find[a]] = find(b);//把a的祖宗节点赋值为b的祖宗节点
```



### 维护size的并查集

```c++
int p[N],size[N];
//p[]存储每一个点的祖宗节点，size[]只有祖宗节点有意义，表示祖宗节点所在集合中点的数量

//返回x的祖宗节点
int find(int x){
if(p[x] != x) p[x] = find(p[x]);
return p[x];
}

//初始化，假定节点编号是1~n
for(int i = 1;i<=n;i++){
p[i] = i;
size[i] = 1;}

//合并a和b所在的两个集合:
size[find(b)] += size[find(a)]
p[find(a)] = find(b);

```



### 维护到祖宗节点距离的并查集

```c++

    int p[N], d[N];
    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量

```



<[836. 合并集合 - AcWing题库](https://www.acwing.com/problem/content/838/)>

```
#include<iostream>

using namespace std;

const int N=100010;
int p[N];//定义多个集合

int find(int x)
{
    if(p[x]!=x) p[x]=find(p[x]);
    /*
    经上述可以发现,每个集合中只有祖宗节点的p[x]值等于他自己,即:
    p[x]=x;
    */
    return p[x];
    //找到了便返回祖宗节点的值
}//优化后的并查集：路径压缩

int main()
{
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) p[i]=i;
    while(m--)
    {
        char op[2];
        int a,b;
        scanf("%s%d%d",op,&a,&b);
        if(*op=='M') p[find(a)]=find(b);//集合合并操作
        else
        if(find(a)==find(b))
        //如果祖宗节点一样,就输出yes
        printf("Yes\n");
        else
        printf("No\n");
    }
    return 0;
}

```







## 堆

**如何手写一个堆**

1.插入一个数

```c++
heap[++size] = x;up(size);//在末尾插入一个数，然后再将这个数上浮
```

2.求集合当中的最小值

```c++
heap[1];//小根堆中第一个元素为最小值
```

3.删除最小值

```c++
heap[1] = heap[size];size--;down(1);
//因为直接删除最小值不好删，而删除最后一个元素只需要size--就可以，所以可以先交换两个数，然后再让1这个位置的元素下沉
```

4.删除任意一个元素

```c++
//比如删除第k个元素，跟删除最小值思路一样，跟最后一个元素交换
heap[k] = heap[size];size--;down(k);up(k);
//因为不知道是up还是down，所以两个都写上，但是只会执行一个，因为执行了某一个之后其中一个就不满足条件了
```

5.修改任意一个元素

```c++
heap[k] = x;down(k);up(k);
//跟第四点思路差不多，我就不解释了
```

下面来实现堆的down和up

```c++
//h[N]存储堆中的值,h[1]是堆顶，x的做儿子是2x，右儿子是2x+1
//ph[k]存储第k个插入的点在堆中的位置,也就是堆中的下标
//hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

//交换两个点，及其映射关系
void head_swap(int a,int b){//a，b都是堆中的下标
swap(ph[hp[a]],ph[hp[b]]);//交换a这个位置对应的值是第几个插入的
swap(hp[a],hp[b]);//交换堆中对应下标的值
swap(h[a],h[b]);//交换堆中两个点的值
}
//ph表示第k个插入数现在的位置，hp表示在该位置的数是第k个插入的
//记忆：p(下标) h(堆) ph就是堆映射到下标，hp反之

void down(int u){//u表示下标
int t = u;//假定t这个下标是最小的
if(u * 2 <= size&& h[u*2] < h[t]) t = u*2;
if(u*2 +1 <= size && h[u*2 +1] < h[t]) t = u*2+1;
if(u!=t){
heap_swap(u,t);
down(t);
//因为down要跟下面两个元素比较，所以不能用递归	}
}

void up(int u){
while(u / 2 && h[u] < h[u /2]){
heap_swap(u,u/2);
u >>= 1;//最需要跟上面一个元素比较，所以可以用递归
}
}

//O(n)建堆
for(int i = n /2;i;i--) down(i);
//因为第i个节点的父亲节点一定是i/2，最下层的元素不需要下沉，这样就实现了O(n)的算法

```





## Hash表

### 一般哈希

```c++
(1) 拉链法
    int h[N], e[N], ne[N], idx;

    // 向哈希表中插入一个数
    void insert(int x)
    {
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];
        h[k] = idx ++ ;
    }

    // 在哈希表中查询某个数是否存在
    bool find(int x)
    {
        int k = (x % N + N) % N;//先求余是防止为负数的情况
        for (int i = h[k]; i != -1; i = ne[i])
            if (e[i] == x)
                return true;

        return false;
    }

(2) 开放寻址法
    int h[N];

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x)
    {
        int t = (x % N + N) % N;
        while (h[t] != null && h[t] != x)
        {
            t ++ ;
            if (t == N) t = 0;
        }
        return t;
    }
```



### 字符串哈希

可参考<[【基本算法入门-字符串哈希（Hash）】-C++ - 摸鱼酱 - 博客园 (cnblogs.com)](https://www.cnblogs.com/moyujiang/p/11213535.html)>

<[什么是哈希表？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/107326081)>

![1704078597216](C:\Users\肖翰\Downloads\typora\1704078597216.png)

```c++
#include<iostream>
#include<string>
using namespace std;
typedef unsigned long long ULL;
const int N = 1e5+5,P = 131;//131 13331
ULL h[N],p[N];
// h[i]前i个字符的hash值
// 字符串变成一个p进制数字，体现了字符+顺序，需要确保不同的字符串对应不同的数字
// P = 131 或  13331 Q=2^64，在99%的情况下不会出现冲突
// 使用场景： 两个字符串的子串是否相同

ULL query(int l,int r){
return h[r] - h[l-1]*p[r-l+1];//p[0] = P^0,p[1] = P^1;
}

int main(){
int n,m;
cin >> n >> m;
string x;
cin >> x;
//字符串从1开始编号，h[1]为前一个字符的哈希值
  	p[0] = 1;
    h[0] = 0;
    for(int i = 0;i<n;i++){
p[i+1] = p[i]*P;
h[i+1] = h[i]*P+x[i];//前缀和求整个字符串的哈希值
    while(m--){
        int l1,r1,l2,r2;
        cin>>l1>>r1>>l2>>r2;
        if(query(l1,r1) == query(l2,r2)) printf("Yes\n");
        else printf("No\n");

    }
    return 0;
}
}
```

例题<[1460. 我在哪？ - AcWing题库](https://www.acwing.com/problem/content/1462/)>(字符串哈希+二分)



## c++STL简介

```c++
vector, 变长数组，倍增的思想
    size()  返回元素个数
    empty()  返回是否为空
    clear()  清空
    front()/back()
    push_back()/pop_back()
    begin()/end()
    []
    支持比较运算，按字典序

pair<int, int>
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）

string，字符串
    size()/length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址

queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素

priority_queue, 优先队列，默认是大根堆
    定义：priority_queue<Type, Container, Functional> Type 就是数据类型，Container 就是 容器 类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。 STL里面默认用的是vector），Functional 就是比较的方式。
    size()
    empty()
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;

stack, 栈
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素

deque, 双端队列
    size()
    empty()
    clear()
    front()/back()
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []

    
set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)

    set/multiset
        insert()  插入一个数
        find()  查找一个数
        count()  返回某一个数的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()/upper_bound()
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器
    map/multimap
        insert()  插入的数是一个pair
        erase()  输入的参数是pair或者迭代器
        find()
        []  注意multimap不支持此操作。 时间复杂度是 O(logn)
        lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--

bitset, 圧位
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反

```



duque的应用<[C - Loong Tracking (atcoder.jp)](https://atcoder.jp/contests/abc335/tasks/abc335_c)>

# 常用代码模板3——搜索与图论

## 递归三部曲

- **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
- **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
- **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

## 回溯三部曲

- 回溯函数模板返回值以及参数

在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。

回溯算法中函数返回值一般为void。

再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。

回溯函数伪代码如下：

```text
void backtracking(参数)
```

- 回溯函数终止条件

既然是树形结构，那么我们在讲解[二叉树的递归 (opens new window)](https://programmercarl.com/二叉树的递归遍历.html)的时候，就知道遍历树形结构一定要有终止条件。

所以回溯也有要终止条件。

什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。

所以回溯函数终止条件伪代码如下：

```text
if (终止条件) {
    存放结果;
    return;
}
```

回溯函数遍历过程伪代码如下：

```text
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

- 回溯搜索的遍历过程

在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。

如图：![1704195620116](C:\Users\肖翰\Downloads\typora\1704195620116.png)

for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。

backtracking这里自己调用自己，实现递归。

大家可以从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。

分析完过程，回溯算法模板框架如下：

```text
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 树和图的存储

```c++
树是一种特殊的图，与图的存储方式相同。
对于无向图中的边ab，存储两条有向边a->b, b->a。
因此我们可以只考虑有向图的存储。

(1) 邻接矩阵：g[a][b] 存储边a->b

(2) 邻接表：就是存储每一条边
    //idx 表示存储的第几个节点，相当于malloc 一个节点

// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e(value)[N], ne(next下一个指针)[N], idx;

// 添加一条边a->b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);//-1表明所有头节点指向空
```

详细解释一下e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;![1706506345880](C:\Users\肖翰\Downloads\typora\1706506345880.png)



首先明白数组的两个东西，比如a[i] = t;,i表示下标，t表示i下标存储的值

然后再明白，e,ne,h,idx分别是什么含义

- idx表示用的是哪一个节点了，每有一条新的边就会自增，e[idx]表示先建一个点存3（如上图）
- h[a],表示以a为头节点拓展的其他节点，a->其他，一开始指向-1，表示为空,只有这里的下标用a，其他都用idx，因为idx才能唯一标识，h[a] = idx++（++表示又新建了一个点）
- ne[idx] 表示idx这个点下一个要指向哪里，**ne[idx]=h[a]表示将这个点插进来形成一条边**。为什么不是ne[a]这么写呢，因为只有idx能唯一标识这条点（边），如果用ne[a]这么写很有可能会将前面的覆盖，ne[idx] = h[a]
- e[idx]，存储idx这条边的终点，通过不断的for(int i = h[a]; i != -1; i = ne[i])，表示，对于以a为头节点的邻接表，如：A -> B -> C，i = h[a]表示取a指向的第一条边（idx唯一标识），j=e[i]表示这条边的终点是什么(b,c,d之类的),然后如果i!=-1,-1表示空节点，如果不是空节点，取这个邻接表的下一条边i = ne[i];

> 个人为了弄懂 邻接表表示的模板代码，做了以下工作：
>
> 一、首先 弄清楚 几个数组的含义，然后再去 看 邻接表的表示代码，发现容易理解一些，在这里再次回顾下几个数组的含义：
>
> h[N] : 表示 第 i 个节点的 第一条边的 idx
> ne[M] : 表示 与 第 idx 条边 同起点 的 下一条边 的 idx
> e[M] : 表示 第idx 条边的 终点
>
> N ： 节点数量
> M：边的数量
> i : 节点的下标索引
> idx ： 边的下标索引
>
> 二、然后结合代码模版理解定义
>
> 变量初始化定义：
>
> int h[N], e[M], ne[M], idx;
> 当我们加入一条边的时候：
>
> public static void add(int a,int b){
>      e[idx] = b;      // 记录 加入的边 的终点节点
>      ne[idx] = h[a]; // h[a] 表示 节点 a 为起点的第一条边的下标，ne[idx] = h[a] 表示把 h[a] 这条边接在了 idx 这条边的后面，其实也就是把 a 节点的整条链表 接在了 idx 这条边 后面；目的就是为了下一步 把 idx 这条边 当成 a 节点的单链表的 第一条边，完成把最新的一条边插入到 链表头的操作；
>      h[a] = idx++; // a节点开头的第一条边置为当前边，idx移动到下一条边
> }

**另一种存储方法**

使用vector<int> g[N];//N为点的数量

```c++
//建图非常简单
for(int i = 1;i <= n;i++){
	int x,y;
	cin >> x >> y;
	g[x].push_back(y);
	//如果要建立双向边的话，那就加上
	g[y].push_back(x);
}

//一般的dfs也很好理解
void dfs(int x){
    st[x] = true;
    for(auto i : g[x]){
        if(st[i] != true){
			dfs(i);
        }
    }
}
```



## DFS与BFS

**时间复杂度O(n+m),n表示点数，m表示边数**

### DFS


```c++
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```

<[842. 排列数字 - AcWing题库](https://www.acwing.com/problem/content/description/844/)>

```c++
#include<iostream>
using namespace std;
const int N = 10;
int path[N];//保存序列
int state[N];//数字是否被用过
int n;
void dfs(int u)
{
    if(u > n)//数字填完了，输出
    {
        for(int i = 1; i <= n; i++)//输出方案
            cout << path[i] << " ";
        cout << endl;
    }

    for(int i = 1; i <= n; i++)//空位上可以选择的数字为:1 ~ n
    {
        if(!state[i])//如果数字 i 没有被用过
        {
            path[u] = i;//放入空位
            state[i] = 1;//数字被用，修改状态
            dfs(u + 1);//填下一个位
            state[i] = 0;//回溯，取出 i
        }
    }
}

int main()
{

    cin >> n;
    dfs(1);
}

```

### BFS

BFS适合权值为1的图，权值不为一的可改用dijkstra算法

```c++
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
```



<[844. 走迷宫 - AcWing题库](https://www.acwing.com/problem/content/846/)>

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 110; 
typedef pair<int, int> PII;
int n, m;
int g[N][N];//存放地图
int d[N][N];//存 每一个点到起点的距离
PII q[N * N];//手写队列
int bfs()
{
    int hh = 0, tt = 0;
    q[0] = {0, 0};

    memset(d, - 1, sizeof d);//距离初始化为- 1表示没有走过

    d[0][0] = 0;//表示起点走过了

    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};//x 方向的向量和 y 方向的向量组成的上、右、下、左

    while(hh <= tt)//队列不空
    {
        PII t = q[hh ++ ];//取队头元素

        for(int i = 0; i < 4; i ++ )//枚举4个方向
        {
            int x = t.first + dx[i], y = t.second + dy[i];//x表示沿着此方向走会走到哪个点
            if(x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1)//在边界内 并且是空地可以走 且之前没有走过
            {
                d[x][y] = d[t.first][t.second] + 1;//到起点的距离
                q[ ++ tt ] = {x, y};//新坐标入队
            }
        }
    }
    return d[n - 1][m - 1]; //输出右下角点距起点的距离即可
}
int main() 
{
    cin >> n >> m;
    for(int i = 0; i < n; i ++ )
        for(int j = 0; j < m; j ++ )
            cin >> g[i][j];

    cout << bfs() << endl;

    return 0;
}

```

### 反向建边

<[[总结\]关于反向建图 - goverclock - 博客园 (cnblogs.com)](https://www.cnblogs.com/goverclock/p/14613683.html)>



## 树与图的遍历：拓扑排序

**时间复杂度O(n+m),n表示点数，m表示边数**



```c++
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}

```

<[848. 有向图的拓扑序列 - AcWing题库](https://www.acwing.com/problem/content/850/)>

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 100010;
int e[N], ne[N], idx;//邻接表存储图
int h[N];
int q[N], hh = 0, tt = -1;//队列保存入度为0的点，也就是能够输出的点，
int n, m;//保存图的点数和边数
int d[N];////保存各个点的入度

void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

void topsort(){
    for(int i = 1; i <= n; i++){//遍历一遍顶点的入度。
        if(d[i] == 0)//如果入度为 0, 则可以入队列
            q[++tt] = i;
    }
    while(tt >= hh){//循环处理队列中点的
        int a = q[hh++];
        for(int i = h[a]; i != -1; i = ne[i]){//循环删除 a 发出的边
            int b = e[i];//a 有一条边指向b
            d[b]--;//删除边后，b的入度减1
            if(d[b] == 0)//如果b的入度减为 0,则 b 可以输出，入队列
                q[++tt] = b;
        }
    }
    if(tt == n - 1){//如果队列中的点的个数与图中点的个数相同，则可以进行拓扑排序
        for(int i = 0; i < n; i++){//队列中保存了所有入度为0的点，依次输出
            cout << q[i] << " ";
        }
    }
    else//如果队列中的点的个数与图中点的个数不相同，则可以进行拓扑排序
        cout << -1;//输出-1，代表错误
}


int main(){
    cin >> n >> m;//保存点的个数和边的个数
    memset(h, -1, sizeof h);//初始化邻接矩阵
    while (m -- ){//依次读入边
        int a, b;
        cin >> a >> b;
        d[b]++;//顶点b的入度+1
        add(a, b);//添加到邻接矩阵
    }
    topsort();//进行拓扑排序
    return 0;
}

```



## 最短路

![1704546724633](C:\Users\肖翰\Downloads\typora\1704546724633.png)

可参考<[彻底弄懂最短路径问题 - 加拿大小哥哥 - 博客园 (cnblogs.com)](https://www.cnblogs.com/hxsyl/p/3270401.html)>

### 朴素dijkstra算法

**时间复杂度分析**

- 寻找路径最短的点：$O(n^2)$
- 加入集合：$O(n)$
- 更新距离：$O(m)$
- 所以总的时间复杂度是$O(n^2)$

**适合稠密图**

Dijkstra 的整体思路比较清晰
即进行n（n为n的个数）次迭代去确定每个点到起点的最小值 最后输出的终点的即为我们要找的最短路的距离

所以按照这个思路除了存储图外我们还需要存储两个量

dist[n] //用于存储每个点到起点的最短距离
st[n]   //用于在更新最短距离时 判断当前的点的最短距离是否确定 是否需要更新

每次迭代的过程中我们都先找到当前未确定的最短距离的点中距离最短的点
（至于为什么是这样那么这就涉及到Dijkstra算法的具体数学证明了 ）

``` c++
int t=-1;       //将t设置为-1 因为Dijkstra算法适用于不存在负权边的图
for(int j=1;j<=n;j++)
{
    if(!st[j]&&(t==-1||dist[t]>dist[j])    //该步骤即寻找还未确定最短路的点中路径最短的点
        t=j;
}
```

通过上述操作当前我们的t代表就是剩余未确定最短路的点中 路径最短的点
而与此同时该点的最短路径也已经确定我们将该点标记

``` c++
st[t]=true;
```

也由于这个原因，所以不能解决带有**负权边的问题**

**dijkstra不能解决负权边是因为 dijkstra要求每个点被确定后st[j] = true，dist[j]就是最短距离了，之后就不能再被更新了（一锤子买卖），而如果有负权边的话，那已经确定的点的dist[j]不一定是最短了**

例子：问题：Dijkstar能否处理负权边？（来自《图论》）

​       答案是不能，这与贪心选择性质有关(ps：貌似还是动态规划啊，晕了)，每次都找一个距源点最近的点（dmin），然后将该距离定为这个点到源点的最短路径；但如果存在负权边，那就有可能先通过并不是距源点最近的一个次优点（dmin'），再通过这个负权边L(L<0)，使得路径之和更小（dmin'+L<dmin）,则dmin'+L成为最短路径，并不是dmin，这样dijkstra就被囧掉了。比如n=3，邻接矩阵：
0，3，4
3，0，-2
4，-2，0,用dijkstra求得d[1，2]=3，事实上d[1，2]=2，就是通过了1 - 3 - 2使得路径减小。

然后用这个去更新其余未确定点的最短距离



```c++
for(int j=1;j<=n;j++)
    dist[j]=min(dist[j],dist[t]+g[t][j]);
//这里可能有同学要问j如果从1开始的话 会不会影响之前已经确定的点的最小距离
//但其实是不会 因为按照我们的Dijkstra算法的操作顺序 先确定最短距离的点的距离已经比后确定的要小 所以不会影响
//当然你也可以在循环判断条件里加上if(!st[i])
//这里j从1开始只是为了代码的简洁
```



进行n次迭代后最后就可以确定每个点的最短距离
然后再根据题意输出相应的 要求的最短距离

**代码模板**

```c++
int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        // 用t更新其他点的距离
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

        st[t] = true;
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

```





完整代码<[849. Dijkstra求最短路 I - AcWing题库](https://www.acwing.com/problem/content/description/851/)>

```c++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;

const int N=510;

int g[N][N];    //为稠密阵所以用邻接矩阵存储
int dist[N];    //用于记录每一个点距离第一个点的距离
bool st[N];     //用于记录该点的最短距离是否已经确定

int n,m;

int Dijkstra()
{
    memset(dist, 0x3f,sizeof dist);     //初始化距离  0x3f代表无限大

    dist[1]=0;  //第一个点到自身的距离为0

    for(int i=0;i<n;i++)      //有n个点所以要进行n次 迭代
    {
        int t=-1;       //t存储当前访问的点

        for(int j=1;j<=n;j++)   //这里的j代表的是从1号点开始
            if(!st[j]&&(t==-1||dist[t]>dist[j]))     
                t=j;

        st[t]=true;   

        for(int j=1;j<=n;j++)           //依次更新每个点所到相邻的点路径值，遍历所有点的所有边就是遍历所有边，图论01：01：41yxc讲了
            dist[j]=min(dist[j],dist[t]+g[t][j]);
    }

    if(dist[n]==0x3f3f3f3f) return -1;  //如果第n个点路径为无穷大即不存在最低路径
    return dist[n];
}
int main()
{
    cin>>n>>m;

    memset(g,0x3f,sizeof g);    //初始化图 因为是求最短路径
                                //所以每个点初始为无限大

    while(m--)
    {
        int x,y,z;
        cin>>x>>y>>z;
        g[x][y]=min(g[x][y],z);     //如果发生重边的情况则保留最短的一条边
    }

    cout<<Dijkstra()<<endl;
    return 0;
}

```



### 堆优化版的dijkstra

**时间复杂度分析**

- 寻找路径最短的点：$O(n)$
- 加入集合S：$O(n)$
- 更新距离：$O(mlogn)$

**代码模板**

```c++
typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

```



完整代码

<[850. Dijkstra求最短路 II - AcWing题库](https://www.acwing.com/problem/content/852/)>

```c++
#include<iostream>
#include<cstring>
#include<queue>

using namespace std;

typedef pair<int, int> PII;

const int N = 100010; // 把N改为150010就能ac

// 稀疏图用邻接表来存
int h[N], e[N], ne[N], idx;
int w[N]; // 用来存权重
int dist[N];
bool st[N]; // 如果为true说明这个点的最短路径已经确定

int n, m;

void add(int x, int y, int c)
{
    // 有重边也不要紧，假设1->2有权重为2和3的边，再遍历到点1的时候2号点的距离会更新两次放入堆中
    // 这样堆中会有很多冗余的点，但是在弹出的时候还是会弹出最小值2+x（x为之前确定的最短路径），
    // 并标记st为true，所以下一次弹出3+x会continue不会向下执行。
    w[idx] = c;
    e[idx] = y;
    ne[idx] = h[x]; 
    h[x] = idx++;
}

int dijkstra()
{
    memset(dist, 0x3f, sizeof(dist));
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap; // 定义一个小根堆
    // 这里heap中为什么要存pair呢，首先小根堆是根据距离来排的，所以有一个变量要是距离，
    // 其次在从堆中拿出来的时候要知道知道这个点是哪个点，不然怎么更新邻接点呢？所以第二个变量要存点。
    heap.push({ 0, 1 }); // 这个顺序不能倒，pair排序时是先根据first，再根据second，
                         // 这里显然要根据距离排序
    while(heap.size())
    {
        PII k = heap.top(); // 取不在集合S中距离最短的点
        heap.pop();
        int ver = k.second, distance = k.first;

        if(st[ver]) continue;
        st[ver] = true;

        for(int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i]; // i只是个下标，e中在存的是i这个下标对应的点。
            if(dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({ dist[j], j });
            }
        }
    }
    if(dist[n] == 0x3f3f3f3f) return -1;
    else return dist[n];
}

int main()
{
    memset(h, -1, sizeof(h));
    scanf("%d%d", &n, &m);

    while (m--)
    {
        int x, y, c;
        scanf("%d%d%d", &x, &y, &c);
        add(x, y, c);
    }

    cout << dijkstra() << endl;

    return 0;
}

```

### bellman-ford算法

**时间复杂度分析**

$O(m)$ 其中n为点数，m为边数

**bellman-ford算法的具体步骤**

for n 次

​		for 所有边 a,b,w(松弛操作)

​			dist[b] = min(dist[b],backup[a]+w)

![1704958291334](C:\Users\肖翰\Downloads\typora\1704958291334.png)

 **Dijkstra算法和Bellman算法思想有很大的区别**：Dijkstra算法在求解过程中，源点到集合S内各顶点的最短路径一旦求出，则之后不变了，修改 的仅仅是源点到T集合中各顶点的最短路径长度。Bellman算法在求解过程中，每次循环都要修改所有顶点的dist[ ]，也就是说源点到各顶点最短路径长度一直要到Bellman算法结束才确定下来。

**代码模板**

```c++
int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}

```

完整代码<[853. 有边数限制的最短路 - AcWing题库](https://www.acwing.com/problem/content/855/)>

```c++
#include<iostream>
#include<cstring>

using namespace std;

const int N = 510, M = 10010;

struct Edge {
    int a;
    int b;
    int w;
} e[M];//把每个边保存下来即可
int dist[N];
int back[N];//备份数组防止串联
int n, m, k;//k代表最短路径最多包涵k条边

int bellman_ford() {
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    for (int i = 0; i < k; i++) {//k次循环
        memcpy(back, dist, sizeof dist);
        for (int j = 0; j < m; j++) {//遍历所有边
            int a = e[j].a, b = e[j].b, w = e[j].w;
            dist[b] = min(dist[b], back[a] + w);
            //使用backup:避免给a更新后立马更新b, 这样b一次性最短路径就多了两条边出来
            //为什么可以这样，因为如果一开始没有到达这条边，距离就无穷，更新之后还是无穷，所以不影响结果
        }
    }
    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    else return dist[n];

}

int main() {
    scanf("%d%d%d", &n, &m, &k);
    for (int i = 0; i < m; i++) {
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        e[i] = {a, b, w};
    }
    int res = bellman_ford();
    if (res == -1) puts("impossible");
    else cout << res;

    return 0;
}

```



### spfa 算法（队列优化的Bellman-Ford算法）

**时间复杂度分析**

平均情况下是$O(m)$,最坏情况下是$O(mn)$,n表示点数，m表示边数

Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。

我认为与dijkstra算法最大的差异就是spfa算法返回等待区后还能继续进入备选区，而dijkstra算法不行

<[(单源最短路) Dijkstra算法与SPFA算法的区别与统一 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/573869455)>

**代码模板**

```c++
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中，这个是判断在不在队列，出列了会有false

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

```

### spfa判断负环

**算法分析**
使用spfa算法解决是否存在负环问题

求负环的常用方法，基于SPFA，一般都用方法 2（该题也是用方法 2）：

- 方法 1：统计每个点入队的次数，如果某个点入队n次，则说明存在负环
- 方法 2：统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则也说明存在环



**代码模板**

```c++
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
bool st[N];     // 存储每个点是否在队列中

// 如果存在负环，则返回true，否则返回false。
bool spfa()
{
    // 不需要初始化dist数组
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。

    queue<int> q;
    for (int i = 1; i <= n; i ++ )
    {
        q.push(i);
        st[i] = true;
    }

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}

```



完整代码<[852. spfa判断负环 - AcWing题库](https://www.acwing.com/problem/content/854/)>

```c++
#include <cstring>
#include <iostream>
#include <queue>

using namespace std;

const int N = 2e3 + 10, M = 1e4 + 10;

int n, m;
int head[N], e[M], ne[M], w[M], idx;
bool st[N];
int dist[N];
int cnt[N]; //cnt[x] 表示 当前从1-x的最短路的边数

void add(int a, int b, int c)
{
    e[idx] = b;
    ne[idx] = head[a];
    w[idx] = c;
    head[a] = idx++;
}

bool spfa(){
    // 这里不需要初始化dist数组为 正无穷/初始化的原因是， 如果存在负环， 那么dist不管初始化为多少， 都会被更新

    queue<int> q;

    //不仅仅是1了， 因为点1可能到不了有负环的点， 因此把所有点都加入队列
    for(int i=1;i<=n;i++){
        q.push(i);
        st[i]=true;
    }

    while(q.size()){
        int t = q.front();
        q.pop();
        st[t]=false;
        for(int i = head[t];i!=-1; i=ne[i]){
            int j = e[i];
            if(dist[j]>dist[t]+w[i]){
                dist[j] = dist[t]+w[i];
                cnt[j] = cnt[t]+1;
                if(cnt[j]>=n){
                    return true;
                }
                if(!st[j]){
                    q.push(j);
                    st[j]=true;
                }
            }
        }
    }
    return false;
}

int main()
{
    cin >> n >> m;
    memset(head, -1, sizeof head);
    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }

    if (spfa()) {
        cout << "Yes" << endl;
    }
    else {
        cout << "No" << endl;
    }
    return 0;
}

```

### floyd算法

**时间复杂度分析**

$O(n^3),n表示点数$

通常解决多元汇最短路问题

多源汇最短路问题（Multiple Source Multiple Sink Shortest Path Problem）是指在一个加权图中，找到从多个源点到多个汇点的最短路径。这个问题在网络路由、物流配送、交通规划等领域有着广泛的应用。

**Floyd算法的基本思想**如下：从任意节点A到任意节点B的最短路径不外乎2种可能，1是直接从A到B，2是从A经过若干个节点到B，所以，我们假设dist(AB)为节点A到节点B的最短路径的距离，对于每一个节点K，我们检查dist(AK) + dist(KB) < dist(AB)是否成立，如果成立，证明从A到K再到B的路径比A直接到B的路径短，我们便设置 dist(AB) = dist(AK) + dist(KB)，这样一来，当我们遍历完所有节点K，dist(AB)中记录的便是A到B的最短路径的距离。

<[Floyd算法 - EnigmaJJ - 博客园 (cnblogs.com)](https://www.cnblogs.com/twjcnblog/archive/2011/09/07/2170306.html)>

**代码模板**

```c++
初始化：
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

```



完整代码<[854. Floyd求最短路 - AcWing题库](https://www.acwing.com/problem/content/description/856/)>

```c++
#include <iostream>
using namespace std;

const int N = 210, M = 2e+10, INF = 1e9;

int n, m, k, x, y, z;
int d[N][N];

void floyd() {
    for(int k = 1; k <= n; k++)
        for(int i = 1; i <= n; i++)
            for(int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

int main() {
    cin >> n >> m >> k;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= n; j++)
            if(i == j) d[i][j] = 0;
            else d[i][j] = INF;
    while(m--) {
        cin >> x >> y >> z;
        d[x][y] = min(d[x][y], z);
        //注意保存最小的边
    }
    floyd();
    while(k--) {
        cin >> x >> y;
        if(d[x][y] > INF/2) puts("impossible");
        //由于有负权边存在所以约大过INF/2也很合理
        else cout << d[x][y] << endl;
    }
    return 0;
}

```



### 图论文字复习

>**Dijkstra-朴素O(n^2)**
>
>1. 初始化距离数组, dist[1] = 0, dist[i] = inf;
>
>2. for n次循环 每次循环确定一个min加入S集合中，n次之后就得出所有的最短距离
>
>3. 将不在S中dist_min的点->t
>
>4. t->S加入最短路集合
>
>5. 用t更新到其他点的距离  
>
>   **Dijkstra-堆优化O(mlogm)**
>
>1. 利用邻接表，优先队列
>
>7. 在priority_queue[HTML_REMOVED], greater[HTML_REMOVED] > heap;中将返回堆顶
>
>3. 利用堆顶来更新其他点，并加入堆中类似宽搜**Bellman_fordO(nm)**
>
>注意连锁想象需要备份, struct Edge{inta,b,c} Edge[M];
>初始化dist, 松弛dist[x.b] = min(dist[x.b], backup[x.a]+x.w);
>松弛k次，每次访问m条边
>**Spfa O(n)~O(nm)**
>
>1. 利用队列优化仅加入修改过的地方
>
>2. for k次
>
>3. for 所有边利用宽搜模型去优化bellman_ford算法
>
>4. 更新队列中当前点的所有出边
>
>   **Floyd O(n^3)**
>
>1. 初始化d
>2. k, i, j 去更新d
>
>



## 最小生成树

### 朴素版的prim算法

**时间复杂度分析**

$O(n^2 +m),n表示顶点数，m表示边数$

prim算法和dijkstra算法十分类似，就是在更新距离的时候稍稍有点不同

**代码模板**

```c++
int n; //表示点数
int g[N][N]; //邻接矩阵，存储所有边
int dist[N]; //存储其他带你到当前最小生成树的距离
bool st[N]; //存储每个点是否在生成树中

// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;//表示答案
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;//首先初始化为一个不可能在图中的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;//t表示找到了当前距离到集合中最小的点

        if (i && dist[t] == INF) return INF;

        if (i) res += dist[t];//当有负权回路，下面的更新距离的操作，当t=j时，会被错误的更新，所以要现在更新距离之前加入到答案
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}

```

完整代码<[858. Prim算法求最小生成树 - AcWing题库](https://www.acwing.com/problem/content/860/)>

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 510;
int g[N][N];//存储图
int dt[N];//存储各个节点到生成树的距离
int st[N];//节点是否被加入到生成树中
int pre[N];//节点的前去节点
int n, m;//n 个节点，m 条边

void prim()
{
    memset(dt,0x3f, sizeof(dt));//初始化距离数组为一个很大的数（10亿左右）
    int res= 0;
    dt[1] = 0;//从 1 号节点开始生成 
    for(int i = 0; i < n; i++)//每次循环选出一个点加入到生成树
    {
        int t = -1;
        for(int j = 1; j <= n; j++)//每个节点一次判断
        {
            if(!st[j] && (t == -1 || dt[j] < dt[t]))//如果没有在树中，且到树的距离最短，则选择该点
                t = j;
        }

        //2022.6.1 发现测试用例加强后，需要判断孤立点了
        //如果孤立点，直返输出不能，然后退出
        if(dt[t] == 0x3f3f3f3f) {
            cout << "impossible";
            return;
        }


        st[t] = 1;// 选择该点
        res += dt[t];
        for(int i = 1; i <= n; i++)//更新生成树外的点到生成树的距离
        {
            if(dt[i] > g[t][i] && !st[i])//从 t 到节点 i 的距离小于原来距离，则更新。
            {
                dt[i] = g[t][i];//更新距离
                pre[i] = t;//从 t 到 i 的距离更短，i 的前驱变为 t.
            }
        }
    }

    cout << res;

}

void getPath()//输出各个边
{
    for(int i = n; i > 1; i--)//n 个节点，所以有 n-1 条边。

    {
        cout << i <<" " << pre[i] << " "<< endl;// i 是节点编号，pre[i] 是 i 节点的前驱节点。他们构成一条边。
    }
}

int main()
{
    memset(g, 0x3f, sizeof(g));//各个点之间的距离初始化成很大的数
    cin >> n >> m;//输入节点数和边数
    while(m --)
    {
        int a, b, w;
        cin >> a >> b >> w;//输出边的两个顶点和权重
        g[a][b] = g[b][a] = min(g[a][b],w);//存储权重
    }

    prim();//求最下生成树
    //getPath();//输出路径
    return 0;
}

```



### Kruskal算法

**时间复杂度分析**

$O(mlog(m)),n表示点数，m表示边数$



**代码模板**

```c++
int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父节点数组

struct Edge     // 存储边
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)     // 并查集核心操作
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}


```





## 二分图：染色法、匈牙利算法

### 二分图的概念

**什么叫二分图**

- 有两顶点集且图中每条边的的两个顶点分别位于两个顶点集中，每个顶点集中没有边直接相连接！

- 说人话的定义：图中点通过移动能分成左右两部分，左侧的点只和右侧的点相连，右侧的点只和左侧的点相连。

![1705155781449](C:\Users\肖翰\Downloads\typora\1705155781449.png)

**如果判断一个图是不是二分图？**

- 开始对任意一未染色的顶点染色。

- 判断其相邻的顶点中，若未染色则将其染上和相邻顶点不同的颜色。

- 若已经染色且颜色和相邻顶点的颜色相同则说明不是二分图，若颜色不同则继续判断。

- bfs和dfs可以搞定！

### 染色法判别二分图

**时间复杂度分析**

$O(n+m),n表示点数，m表示边数$

**代码模板**

```c++
int n;      // n表示点数
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}

```



完整代码<[860. 染色法判定二分图 - AcWing题库](https://www.acwing.com/problem/content/862/)>

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010 * 2;
int e[N], ne[N], idx;//邻接表存储图
int h[N];
int color[N];//保存各个点的颜色，0 未染色，1 是红色，2 是黑色
int n, m;//点和边

void add(int a, int b)//邻接表插入点和边
{
    e[idx] = b, ne[idx]= h[a], h[a] = idx++;
}

bool dfs(int u, int c)//深度优先遍历,对邻接表的染色
{
    color[u] = c;//u的点成 c 染色

    //遍历和 u 相邻的点
    for(int i = h[u]; i!= -1; i = ne[i])
    {
        int b = e[i];                   
        if(!color[b])//相邻的点没有颜色,则递归处理这个相邻点
        {
            if(!dfs(b, 3 - c)) return false;//（3 - 1 = 2， 如果 u 的颜色是2，则和 u 相邻的染成 1）
                                            //（3 - 2 = 1， 如果 u 的颜色是1，则和 u 相邻的染成 2）
        }
        else if(color[b] && color[b] != 3 - c)//如果已经染色，判断颜色是否为 3 - c
        {                                     
            return false;//如果不是，说明冲突，返回                   
        }
    }
    return true;
}

int main()
{
    memset(h, -1, sizeof h);//初始化邻接表
    cin >> n >> m;
    for(int i = 1; i <= m; i++)//读入边
    {
        int a, b;
        cin >> a >> b;
        add(a, b), add(b, a);
    }
    for(int i = 1; i <= n; i++)//遍历点
    {
        if(!color[i])//如果没染色
        {
            if(!dfs(i, 1))//染色该点，并递归处理和它相邻的点
            {//只要在dfs过程的返回false，也就是出现矛盾，那就输出no
                cout << "No" << endl;//出现矛盾，输出NO 
                return 0;
            }

        }
    }
    cout << "Yes" << endl;//全部染色完成，没有矛盾，输出YES
    return 0;
}

```





### 匈牙利算法

**时间复杂度分析**

$O(mn),n表示点数，m表示边数$

作用：求二分图的最大匹配

> 二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M的边集 {E}{} 中的任意两条边都不依附于同一个顶点，则称 M是一个匹配。
>
> 二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。

**代码模板**

```c++
int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}

```



# 常用代码模板4——数学知识

## 质数

### 判断质数

```c++
bool is_prime(int n){
    if(n < 2) return false;
    for(int i = 2;i <= n / i;i ++){ //优化内容
        if(n % i == 0){
            return false;
        }
    }
    return true;
}
//为什么不i*i<=n或者i<=sqrt(n)
//第一个是会有溢出的风险，这样数据就变成了负数，不准确
//第二个是由于sqrt函数执行比较慢，效率低
```

### 分解质因数

- 根据**算术基本定理**，不考虑排列顺序的情况下，每个正整数都能够以唯一的方式表示成它的质因数的乘积。
  n=p1^a1^ * p2^a2^ *p3^a3^..... pn^an^

- 比如一个数16 在分解时先找到2这个质因子，然后由于16/2后还可以/2，所以会在2这个质因子上产生次方
  不优化版本：从2~n 找到能整除的因子然后算次方
  提前不满意这个不优化版本

- 这里有个性质：n中最多只含有一个大于sqrt(n)的因子。证明通过反证法：如果有两个大于sqrt(n)的因子，那么相乘会大于n，矛盾。证毕

- 于是我们发现最多只有一个大于sqrt(n)的因子，对其进行优化。先考虑比sqrt(n)小的，代码和质数的判定类似
  最后如果n还是>1，说明这就是大于sqrt(n)的唯一质因子，输出即可

  

```c++
#include<iostream>
#include<algorithm>
using namespace std;
int main(void)
{
    int n;cin>>n;
    while(n--)
    {
        int a;cin>>a;
        for(int i=2;i<=a/i;i++)
        {
            if(a%i==0)//说明i是a的质因子
            {
                int s=0;//s表示次数比如说2的三次方
                while(a%i==0)//那么就把a除干净
                {
                    a/=i;
                    s++;
                }
                cout<<i<<" "<<s<<endl;  
            }

        }
        if(a>1) cout<<a<<' '<<1<<endl; //比如a=3,5的时候
        cout<<endl;
    }
return 0;    
}

```

###  最普通的筛法$O(nlogn)$



```c++
void get_primes2(){
    for(int i=2;i<=n;i++){

        if(!st[i]) primes[cnt++]=i;//把素数存起来
        for(int j=i;j<=n;j+=i){//不管是合数还是质数，都用来筛掉后面它的倍数
            st[j]=true;
        }
    }
}
```

### **埃氏筛法$P(nloglogn)$**



```c++
void get_primes1(){
    for(int i=2;i<=n;i++){
        if(!st[i]){
            primes[cnt++]=i;
            for(int j=i;j<=n;j+=i) st[j]=true;//可以用质数就把所有的合数都筛掉；
        }
    }
}
//为什么筛质数就行了呢，因为所有合数可以分解成质数，把质数筛选出来也就把所有合数筛选了一遍，是一种优化
```

### **线性筛法$O(n)$**

比较常用

关键就是先将最小质因子筛掉

枚举已记录的质数（如果合数已越界则中断)

1. 合数未越界，则划掉合数
2. 条件%p==0,保证合数只被最小质因子划掉
   - 若ⅰ是质数，则最多枚举到自身中断
   - 若ⅰ是合数，则最多枚举到自身的最小质数中断

[G08 筛质数 埃氏筛法 线性筛法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1kG411u7Ze/?spm_id_from=333.337.search-card.all.click&vd_source=e03b7d988550b29e55118b7d8e6cab3c)

```c++
void get_primes(){
    //外层从2~n迭代，因为这毕竟算的是1~n中质数的个数，而不是某个数是不是质数的判定
    for(int i=2;i<=n;i++){
        if(!st[i]) primes[cnt++]=i;
        for(int j=1;primes[j]<=n/i;j++){//primes[j]<=n/i:变形一下得到——primes[j]*i<=n,把大于n的合数都筛了就
        //没啥意义了
            st[primes[j]*i]=true;//用最小质因子去筛合数
            //把小于n的全部筛掉了

            //1)当i%primes[j]!=0时,说明此时遍历到的primes[j]不是i的质因子，那么只可能是此时的primes[j]<i的
            //最小质因子,所以primes[j]*i的最小质因子就是primes[j];
            //2)当有i%primes[j]==0时,说明i的最小质因子是primes[j],因此primes[j]*i的最小质因子也就应该是
            //prime[j]，之后接着用st[primes[j+1]*i]=true去筛合数时，就不是用最小质因子去更新了,因为i有最小
            //质因子primes[j]<primes[j+1],此时的primes[j+1]不是primes[j+1]*i的最小质因子，此时就应该
            //退出循环，避免之后重复进行筛选。
            if(i%primes[j]==0) break;//筛选这个i没意义了，因为当j=0，1等等比较小的视乎已经是最小质因子了
            
        }
    }

}

```



## 约数

### 试除法求所有约数

```c++
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);//防止重复加入数据
        }
    sort(res.begin(), res.end());
    return res;
}
```



### 约数个数和约数之和

**代码模板**

```c++1
如果 N = p1^c1 * p2^c2 * ... *pk^ck
约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)
约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)
```

完整代码

<[870. 约数个数 - AcWing题库](https://www.acwing.com/problem/content/872/)>

![1705237929807](C:\Users\肖翰\Downloads\typora\1705237929807.png)

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL; 
const int mod = 1e9 + 7;
int main(){
    int n,x;
    LL ans = 1;
    unordered_map<int,int> hash;
    cin >> n;
    while(n--){
        cin >> x;
        for(int i = 2;i <= x/i; ++i){
            while(x % i == 0){
                x /= i;
                hash[i] ++;
            }
        }
        if(x > 1) hash[x] ++;
    }//分解质因数的方法
    for(auto i : hash) ans = ans*(i.second + 1) % mod;
    cout << ans;
    return 0;
}

```

<[870. 约数个数 - AcWing题库](https://www.acwing.com/problem/content/872/)>

- 约数之和： (p1 ^0^+ p1^1^ + ... + p1^c1^) * ... * (pk^0^ + pk^1^ + ... + pk^ck^)
- 为什么是这个呢？原因很简单，你在每一个括号选取一个数然后进行组合就是一个约数，所有的组合之和就是约数之和

```c++
#include <iostream>
#include <unordered_map>

using namespace std;

typedef long long ll;

const int mod = 1e9 + 7;

unordered_map<int, int> primes;

int main()
{
    int n, x;
    cin >> n;
    while (n --)
    {
        cin >> x;
        for (int i = 2; i <= x / i; i ++)
            while (x % i == 0)
            {
                primes[i] ++;
                x /= i;
            }
        if (x > 1) primes[x] ++;
    }
    ll res = 1;
    for (auto p : primes)
    {
        ll a = p.first, b = p.second;
        ll t = 1;
        while (b --)  t = (t * a + 1) % mod;
        res = res * t % mod;
    }
    cout << res;

    return 0;
}

```

### 辗转相除法——欧几里得算法

<[一文看懂什么是欧几里得算法！多图演示辗转相除算法究竟是什么！为什么要这样开展！多图预警！_欧几里得算法是啥-CSDN博客](https://blog.csdn.net/2201_75314884/article/details/131206814?spm=1001.2014.3001.5506)>

可利用几何的角度来理解

```c++
//a表示长边，b表示短边，当短边为0的时候，此时长边就是最大公约数
int Gcd(int a, int b)
{
	if (b == 0)
	{
		return a;
	}
	else
	{
		return Gcd(b, a % b);
	}
}
```

###最小公倍数

利用欧几里得算法求得

```c++
long long lcm(long long x,long long y){
	return x*y/gcd(x,y);
}//x*y可以看成gcd(x,y)(c*d),c*d就是最小公倍数
```



## 欧拉函数

### 直接求欧拉函数

互质：最大公约数为1

对于正整数n,欧拉函数是小于或等于的正整数中与n互质的数的数目，记作$\psi(n)$,$\psi(1)=1$,记住公式即可

![1705409516701](C:\Users\肖翰\Downloads\typora\1705409516701.png)

```c++
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);//必须先除，先乘有可能会造成溢出
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);

    return res;
}
//res = res / i * (i - 1);也可以放在while那一步，因为res与x没有函数关系，所以while中x的改变不影响res的取值
```



### 线性筛法求欧拉函数

**代码解释**

- 质数i的欧拉函数即为phi[i] = i - 1: 1~i均与i互质，共i-1个

- phi[primes[j] * i] 分两种情况：

  ①i % primes[j] == 0时：primes[j] 是 i的最小质因子（因为for循环从小到大遍历，肯定先遍历到小的），也是primes[j] * i 的最小质因子，因此1 - 1 / primes[j]这一项在phi[i]中计算过了，只需将只需将基数N修正为primes[j]倍，最终结果为phi[i] * primes[j]。

  可以想象n = primes[j] * i,然后 primes[j] 和 i可以分解为

  p1^a1^ * p2^a2^ *p3^a3^..... pn^an^

  ![1705567881517](C:\Users\肖翰\Downloads\typora\1705567881517.png)

  ②i % primes[j] != 0：primes[j]不是i的质因子，只是primes[j] * i的最小质因子，因此不仅需要将基数N修正为primes[j]倍，还需要补上1 - 1 / primes[j]这一项，因此最终结果phi[i] * (primes[j] - 1)

  ![1705568164285](C:\Users\肖翰\Downloads\typora\1705568164285.png)

<[874. 筛法求欧拉函数 - AcWing题库](https://www.acwing.com/problem/content/876/)>

```c++
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1000010;

int primes[N], cnt;
int phi[N];
bool st[N];

void get_eulers(int n)
{
    phi[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        if (!st[i])
        {
            primes[cnt++] = i;
            phi[i] = i - 1; 
        }
        for (int j = 0; primes[j] <= n / i; j++)
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0)
            {
                phi[primes[j] * i] = phi[i] * primes[j]; 
                break;
            }
            phi[primes[j] * i] = phi[i] * (primes[j] - 1);
        }
    }
}

int main()
{
    int n;
    cin >> n;

    get_eulers(n);

    LL res = 0;
    for (int i = 1; i <= n; i++) res += phi[i];
    printf("%lld\n", res);

    return 0;
}

```



## 快速幂

**欧拉定理**

若a与n互质则，$a^{\phi(n)}≡1(mod~n)$

**证明**

由于a与n互质，设$\phi(n)=k$，则说明有1~n-1有k个数与n互质

那么1~n中$a_{k1},a_{k2}……a_{k}$一共k个数

那也有$aa_{k1},aa_{k2}……aa_{k}$k个互不相同，且和n互质的数

有$a^{\phi(n)}(a_{k1}a_{k2}a_{k}）$≡$a_{k1}a_{k2}a_{k}（mod~n）$

也就是$a^{\phi(n)}≡1(mod~n)$

假设n是质数，用p表示

那么$a^{\phi(p)}≡1(mod~p)$

又由$\phi(p) = p-1$

即$a^{p-1}≡1(mod~n)$

### 快速求出a^b

作用：求出$a^b$, 0<a,b<1e9,这个时候用简单的乘法时间复杂度是O（n)的，但是将b写成2进制数，就可以把

$ a^b =a^{2^0} + a^{2^1}+...+a^{2^k} $

时间复杂度是O(logn)的

然后对于取模有一下性质

> (a + b) % p = (a % p + b % p) % p
>
> (a - b) % p = (a % p - b % p) % p
>
> (a * b) % p = (a % p * b % p) % p
>
> a ^ b % p = ((a % p)^b) % p

**代码模板**

```c++
求 m^k mod p，时间复杂度 O(logk)。

int qmi(int m, int k, int p)
{
    int res = 1 % p, t = m;
    while (k)
    {
        if (k&1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}
```



```c++
//一般需要用到快速幂的地方，指数都会非常大，同时需要进行取模运算
//故为了防止爆掉应该开long long，所以干脆把所有的变量都开long long，这时如果a,b,p都是int就一定
//不会爆

//求完结果再取模和每一步运算都取模是一样的（b右移就不用了）
//若a和b都是long long，那么它还是会爆，这时候就需要写个快速乘来算ans了，将注释去掉，然后把
// ans = (ans * a) % p; 改成 ans = quick_mul(ans, a, p);
//再把a = (a * a) % p; 改成 a = quick_mul(a, a, p);
//当加法都爆了那就没办法了，不过一般不会这样
//快速乘与快速幂同理

#include <iostream>
using namespace std;

long long quick_power(long long a, long long b, long long p);
//long long quick_mul(long long a, long long b, long long p);

int main()
{
	long long a, b, p;
	cin >> a >> b >> p;
	long long ans = quick_power(a, b, p);
	cout << ans << endl;

	system("pause");

	return 0;
}

long long quick_power(long long a, long long b, long long p)
{
	long long ans = 1;
	while (b)
	{
		if (b & 1) ans = (ans * a) % p;
		b >>= 1;
		a = (a * a) % p;
	}
	return ans;
}

//long long quick_mul(long long a, long long b, long long p)
//{
//	long long ans = 0;
//	while (b)
//	{
//		if (b & 1) ans = (ans + a) % p;
//		b >>= 1;
//		a = (a + a) % p;
//	}
//	return ans;
//}
```





完整代码<[AcWing 875. 快速幂-数论-C++(递归、迭代、暴力) - AcWing](https://www.acwing.com/solution/content/15293/)>

```c++
#include<iostream>
using namespace std;
long long qmi(long long a,int b,int p)
{
    long long res=1;
    while(b)//对b进行二进制化,从低位到高位
    {
        //如果b的二进制表示的第0位为1,则乘上当前的a
        if(b&1) res = res *a %p;
        //b右移一位
        b>>=1;
        //更新a,a依次为a^{2^0},a^{2^1},a^{2^2},....,a^{2^logb}
        a=a*a%p;//用到取模的第四个性质，是相等的
    }
    return res;
}
int main()
{
    int n;
    cin>>n;
    while(n--)
    {
        cin.tie(0);
        ios::sync_with_stdio(false);
        int a,b,p;
        long long res=1;
        cin>>a>>b>>p;
        res = qmi(a,b,p);
        cout<<res<<endl;
    }
    return 0;
}

```

### 快速幂求逆元

为什么要有模逆元这个概念

因为在除法时mod运算不满足基本四则运算

![1705738086395](C:\Users\肖翰\Downloads\typora\1705738086395.png)

因此通过求其逆元来变成乘法来达到目的

下面给出逆元的概念

![1705738194619](C:\Users\肖翰\Downloads\typora\1705738194619.png)

**乘法逆元的定义**

>![1705738525269](C:\Users\肖翰\Downloads\typora\1705738525269.png)



**当n为质数时，可以用快速幂求逆元**

a / b ≡ a * x(mod n)

两边同乘b可得a ≡ a*b*x(mod n)

即1 ≡ b*x(mod n)

同b * x≡1(mod n) 这也回归了逆元最基本的定义

由**费马小定理**（在快速幂中证明欧拉定理时给出了证明）可知，当n为质数时

**b^(n-1) ≡ 1(mod n)**

拆一个b出来可得b*b^(n-2) ≡1(mod n)

**故当n为质数时，b的乘法逆元为x = b^(n-2)**

```c++
#include <iostream>
using namespace std;
typedef long long LL;

LL qmi(int a, int b, int p)
{
    LL res = 1;
    while(b){
        if(b & 1) res = res * a % p;
        a = (LL)a * a % p;
        b >>= 1;
    }
    return res;
}

int main()
{
    int n; cin >> n;
    while(n --){
        int a, p;
        cin >> a >> p;
        if(a % p == 0) puts("impossible");
        else cout << qmi(a, p - 2, p) << endl;
    }
    return 0;
}

```



**当n不是质数时，可以用扩展欧几里得算法**

a有逆元的充分条件是a与p互质，所以gcd(a,p) = 1

假设a的逆元为x，那么有a*x≡1(mod p)

等价: ax +py = 1

exgcd(a,p,x,y)

```c++
#include <iostream>
using namespace std;
typedef long long LL;
int n;

int exgcd(int a, int b, int &x, int &y)
{
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}


int main()
{
    cin >> n;
    while (n --)
    {
        int a, p, x, y;
        // if (a < p) swap(a, p);
        cin >>  a >> p;
        int d = exgcd(a, p, x, y);
        if (d == 1) cout << ((LL)x + p) % p << endl;//保证x是正数
        else puts("impossible");

    }
    return 0;
}

```





## 扩展欧几里得算法

**裴蜀定理**

对于任意正整数a,b,一定存在整数x,y，使得

ax + by = (a,b) //(a,b)表示a，b的最大公约数

> 若 a , b 是整数,且 gcd ⁡ ( a , b ) = d ,那么对于任意的整数 x , y , a x + b y都一定是 d  的倍数，特别地，一定存在整数 x , y，使 a x + b y = d成立。 

证明过程可参考<[裴蜀定理另证_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1BD4y1x7hp/?spm_id_from=333.337.search-card.all.click&vd_source=e03b7d988550b29e55118b7d8e6cab3c)>

1. 扩展欧几里得

用于求解方程 $a x+b y=\operatorname{gcd}(a, b)$ 的解
当 $b=0$ 时 $a x+b y=a$ 故而 $x=1, y=0$
当 $b \neq 0$ 时
因为
$$
\operatorname{gcd}(a, b)=\operatorname{gcd}(b, a \% b)
$$

而
$$
\begin{gathered}
b x^{\prime}+(a \% b) y^{\prime}=g c d(b, a \% b) \\
b x^{\prime}+(a-\lfloor a / b\rfloor * b) y^{\prime}=g c d(b, a \% b) \\
a y^{\prime}+b\left(x^{\prime}-\lfloor a / b\rfloor * y^{\prime}\right)=\operatorname{gcd}(b, a \% b)=\operatorname{gcd}(a, b)
\end{gathered}
$$

故而
$$
x=y^{\prime}, \quad y=x^{\prime}-\lfloor a / b\rfloor * y^{\prime}
$$

因此可以采取递归算法 先求出下一层的 $x^{\prime}$ 和 $y^{\prime}$ 再利用上述公式回代即可
2. 对于求解更一般的方程 $a x+b y=c$

设 $d=\operatorname{gcd}(a, b)$ 则其有解当且仅当 $d \mid c$
求解方法如下:
用扩展欧几里得求出 $a x_0+b y_0=d$ 的解
则 $a\left(x_0 * c / d\right)+b\left(y_0 * c / d\right)=c$
故而特解为 $x^{\prime}=x_0 * c / d, \quad y^{\prime}=y_0 * c / d$
而通解 $=$ 特解 + 文次解
而齐次解即为方程 $a x+b y=0$ 的解

故而通解为 $x=x^{\prime}+k * b / d, y=y^{\prime}-k * a / d \quad k \in \mathrm{z}$若令 $t=b / d$, 则对于 $x$ 的最小非负整数解为 $\left(x^{\prime} \% t+t\right) \% t$
3.应用: 求解一次同余方程 $a x \equiv b(\operatorname{modm})$

则等价于求
$$
\begin{gathered}
a x=m *(-y)+b \\
a x+m y=b
\end{gathered}
$$

有解条件为 $\operatorname{gcd}(a, m) \mid b$, 然后用扩展欧几里得求解即可
特别的 当 $b=1$ 且 $a$ 与 $m$ 互质时 则所求的 $x$ 即为 $a$ 的逆元

**代码模板**

有两种更新方式

设 $d=\operatorname{gcd}(a, b)$
方式一:
$\operatorname{exgcd}(a, b, x, y)=\operatorname{exgcd}(b, a \% b, y, x)$
$\operatorname{exgcd}(b, a \% b, y, x) \Rightarrow \quad b \times y+\left(a-\left[\frac{a}{b}\right] \times b\right) \times x=d \Rightarrow \quad b \times\left(y-\left[\frac{a}{b}\right] \times x\right)+a \times x=d$
$\therefore y$ 更新为 $y-\left[\frac{a}{b}\right] \times x$
方式二:
$\operatorname{exgcd}(a, b, x, y)=\operatorname{exgcd}(b, a \% b, x, y)$
$\operatorname{exgcd}(b, a \% b, x, y) \Rightarrow \quad b \times x+\left(a-\left[\frac{a}{b}\right] \times b\right) \times y=d \Rightarrow \quad p \times\left(x-\left[\frac{a}{b}\right] \times y\right)+a \times y$
$\therefore y$ 更新为 $x-\left[\frac{a}{b}\right] \times y, x$ 更新为 $y$

```c++
// 求x, y，使得ax + by = gcd(a, b)
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;//边界情况
        return a;
    }
    int d = exgcd(b, a % b, y, x);//b和a%b的系数分别是y和x
    
    y -= (a/b) * x;//x的系数不变，y的系数变成这个
    return d;
}
```



完整代码<[877. 扩展欧几里得算法 - AcWing题库](https://www.acwing.com/problem/content/879/)>

```c++
#include<bits/stdc++.h>
using namespace std;
int exgcd(int a, int b, int &x, int &y){//返回gcd(a,b) 并求出解(引用带回)
    if(b==0){
        x = 1, y = 0;
        return a;
    }
    int x1,y1,gcd;
    gcd = exgcd(b, a%b, x1, y1);
    x = y1, y = x1 - a/b*y1;
    return gcd; 
}
int main(){
    int n,a,b,x,y;
    cin>>n;
    while(n--){
        cin>>a>>b;
        exgcd(a,b,x,y);
        cout<<x<<" "<<y<<endl;
    }
    return 0;
}

```



## 中国剩余定理

在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。

在《孙子歌诀》中给出了解决这个问题的解法：**三人同行七十稀，五树梅花廿一支，七子团圆正半月，除百零五便得知。**很是朗朗上口，但这是什么意思呢？

具体解法分三步：

找出三个数：

1.从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除余1 的最小数21，最后从5和7的公倍数中找出除3余1的最小数70。

2.用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加（15*2+21*3+70*2）得到和233。

3.用233除以3，5，7三个数的最小公倍数105，得到余数23，即233%105=23。这个余数23就是符合条件的最小数。

就这么简单。我们在感叹神奇的同时不禁想知道古人是如何想到这个方法的，有什么基本的数学依据吗

原理参考

<[中国剩余定理 - 王陸 - 博客园 (cnblogs.com)](https://www.cnblogs.com/wkfvawl/p/9633188.html)>

**一些问题**

![Image](https://message.biliimg.com/bfs/im_new/98808386130f31c3bcf6bfe4546cdf523494368646269902.png)

我当时问为啥m1 = n1/2,不是n1/3,n1/4这些？

因为直接找n1很难找，我们就想一下有没有什么好的方法，我们可以定义一个m1 = n1 / (余数)

这个要看余数是几，比如上面的求mod之后余数是二，那我就将m1 = n1/2，为什么呢，因为这样可以将2提出来然后就可以将m1拆成除去3以外的所有除数相乘 再乘一个x，这个x就是m1的模逆元，这个模逆元可以用扩展欧几里得算出，然后再乘回余数去，这样就得到了n1

1. 设![M = m_1 \times m_2 \times \cdots \times m_n = \prod_{i=1}^n m_i](C:\Users\肖翰\Downloads\typora\6b0400edc03f40c7f705bc76de4a6f80.png)是整数*m*1, *m*2, ... , *m*n的乘积，并设![M_i = M/m_i, \; \; \forall i \in \{1, 2, \cdots , n\}](C:\Users\肖翰\Downloads\typora\e5ddade7b3a0ce3387ddbe17ded85447.png)是除了*m*i以外的*n* - 1个整数的乘积。
2. 设![t_i = M_i^{-1}](http://upload.wikimedia.org/math/d/3/6/d36ee115ef4e61f26022f0752b0a65df.png)为![M_i](http://upload.wikimedia.org/math/e/9/7/e9728c4330012bb285d12f5b50f4621b.png)模![m_i](http://upload.wikimedia.org/math/2/1/2/212abcc00be63b38e4cd48603ee59f7d.png)的数论倒数：![t_i M_i \equiv 1 \pmod {m_i},  \; \; \forall i \in \{1, 2, \cdots , n\}.](C:\Users\肖翰\Downloads\typora\6b610f369610110a6dce329915dfbeb5.png)
3. 方程组![(S)](http://upload.wikimedia.org/math/b/7/a/b7aa5812e42033b7f8c213dc0f2e8994.png)的通解形式为：![x = a_1 t_1 M_1 + a_2 t_2 M_2 + \cdots + a_n t_n M_n + k M= k M + \sum_{i=1}^n a_i t_i M_i, \quad k \in \mathbb{Z}.](C:\Users\肖翰\Downloads\typora\48d5a9a766df9cb2271b848035611d46.png) 在模![M](http://upload.wikimedia.org/math/6/9/6/69691c7bdcc3ce6d5d8a1361f22d04ac.png)的意义下，方程组![(S)](http://upload.wikimedia.org/math/b/7/a/b7aa5812e42033b7f8c213dc0f2e8994.png)只有一个解：![x = \sum_{i=1}^n a_i t_i M_i.](C:\Users\肖翰\Downloads\typora\00763feb484218324266687eaae56b31.png)



```c++
void exgcd(int a1,int b,int &x,int &y)
{
    if(b==0)
    {
        x=1;
        y=0;
        return ;
    }
    exgcd(b,a1%b,x,y);
    int t=x;
    x=y;
    y=t-(a1/b)*y;
}
int CRT(int a[],int m[],int n)
{
    int M=1,ans=0,t,x,y;
    for(int i=0; i<n; i++)
    {
        M*=m[i];///M为除数乘积
    }
    for(int i=0; i<n; i++)
    {
        t=M/m[i];///除了mi以外的n-1个整数乘积
        exgcd(t,m[i],x,y);///求逆元，由扩展欧几里得转换成t*ti+m[i]*y=1来求ti
        ans=(ans+a[i]*x*t)%M;
    }
    return (ans+M)%M;
}
```



## 高斯消元

**算法步骤**

- 找到当前列绝对值最大的一行
- 把这一行换到最上面
- 将该行的第一个数变成1
- 将下面所有行的当前列变为0

**代码模板**

```c++
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 110;
const double eps = 1e-6;

int n;
double a[N][N];


int gauss()
{
    int c, r;// c 代表 列 col ， r 代表 行 row
    for (c = 0, r = 0; c < n; c ++ )
    {
        int t = r;// 先找到当前这一列，绝对值最大的一个数字所在的行号
        for (int i = r; i < n; i ++ )
            if (fabs(a[i][c]) > fabs(a[t][c]))
                t = i;

        if (fabs(a[t][c]) < eps) continue;// 如果当前这一列的最大数都是 0 ，那么所有数都是 0，就没必要去算了，因为它的约束方程，可能在上面几行

        for (int i = c; i < n + 1; i ++ ) swap(a[t][i], a[r][i]);//// 把当前这一行，换到最上面（不是第一行，是第 r 行）去
        for (int i = n; i >= c; i -- ) a[r][i] /= a[r][c];// 把当前这一行的第一个数，变成 1， 方程两边同时除以 第一个数，必须要到着算，不然第一个数直接变1，系数就被篡改，后面的数字没法算
        for (int i = r + 1; i < n; i ++ )// 把当前列下面的所有数，全部消成 0
            if (fabs(a[i][c]) > eps)// 如果非0 再操作，已经是 0就没必要操作了
                for (int j = n; j >= c; j -- )// 从后往前，当前行的每个数字，都减去对应列 * 行首非0的数字，这样就能保证第一个数字是 a[i][0] -= 1*a[i][0];
                    a[i][j] -= a[r][j] * a[i][c];

        r ++ ;// 这一行的工作做完，换下一行
    }

    if (r < n)// 说明剩下方程的个数是小于 n 的，说明不是唯一解，判断是无解还是无穷多解
    {// 因为已经是阶梯型，所以 r ~ n-1 的值应该都为 0
        for (int i = r; i < n; i ++ )// 
            if (fabs(a[i][n]) > eps)// a[i][n] 代表 b_i ,即 左边=0，右边=b_i,0 != b_i, 所以无解。
                return 2;
        return 1;// 否则， 0 = 0，就是r ~ n-1的方程都是多余方程
    }
    // 唯一解 ↓，从下往上回代，得到方程的解
    for (int i = n - 1; i >= 0; i -- )
        for (int j = i + 1; j < n; j ++ )
            a[i][n] -= a[j][n] * a[i][j];//因为只要得到解，所以只用对 b_i 进行操作，中间的值，可以不用操作，因为不用输出

    return 0;
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n + 1; j ++ )
            cin >> a[i][j];

    int t = gauss();

    if (t == 0)
    {
        for (int i = 0; i < n; i ++ ) printf("%.2lf\n", a[i][n]);
    }
    else if (t == 1) puts("Infinite group solutions");
    else puts("No solution");

    return 0;
}

```



## 组合计数

### 求组合数Ⅰ

**时间复杂度分析**

$O(n^2)$

**适用情况**

当询问次数非常多的时候，1 <= n <= 100000

但是数据a,b不大时，1 <= a,b <= 2000

求出所有的$C_{a}^{b}$ ,下面给出一个递推式

$C_{a}^{b} = C_{a-1}^{b-1}+C_{a-1}^{b}$

递推式的理解：从a个苹果中选出b个苹果的次数可以分为两种情况

- 选中一个苹果：此时已经选中了这个苹果，剩下的只要从a-1中选出b-1个苹果
- 不选这个苹果：那显然就是从剩下a-1个苹果中选出b个苹果

```c++
#include<iostream>
using namespace std;
const int mod = 1e9+7;
long long f[2010][2010];
int main()
{
    //预处理
    for(int i=0;i<=2000;i++)
    {
        for(int j=0;j<=i;j++)
        {
            if(!j) f[i][j]=1;
            else f[i][j]=(f[i-1][j-1]+f[i-1][j])%mod;//递推求出每一个组合数
        }
    }
    int n;
    cin>>n;
    while(n--)
    {
        int a,b;
        cin>>a>>b;
        printf("%ld\n",f[a][b]);
    }
}

```

[F-小红的子序列权值和（easy）_牛客周赛 Round 35 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/76133/F)

```c++
const int p = 1e9+7;
int tong[5];
int n;
ll C[1010][1010];




int main(){
	cin >> n;
	
	for(int i = 0; i<=n;i++){
		for(int j = 0; j <= i;j++){
			if(j == 0 || j == i) C[i][j] = 1;
			else {
				
				C[i][j] = (C[i-1][j]+C[i-1][j-1])%p;
				
			}
		}
	} 
	for(int i = 1; i<= n;i++){
		int x;
		cin >> x;
		tong[x]++;
	}
	ll temp = 1;
	ll ans = 0;
	for(int i = 1; i<= tong[1];i++) temp = temp * 2 % p;
	
	for(int i = 0; i<= tong[2];i++){
		for(int j = 0; j<= tong[3];j++){
			ans += (C[tong[2]][i]*C[tong[3]][j]%p*(i+1)%p*(j+1)%p*temp)%p;
			ans %= p;
		}
	}
	cout << ans - 1 << endl;
	
}
```



### 求组合数Ⅱ

**时间复杂度**

$O(a*log(mod))$

**适用情况**

1 <= n <= 10^4,1 <= b <= a <= 10^5

这里采用另一种预处理的方式

![1705830966688](C:\Users\肖翰\Downloads\typora\1705830966688.png)

通过求模逆元来求组合数

```c++
#include<iostream>
using namespace std;
const int mod=1e9+7,N=1e5+10;
typedef long long LL;
long long fac[N],infac[N];
int quick_pow(int a, int k, int p)
{
    int res = 1;
    while (k)
    {
        if (k & 1) res = (LL)res * a % p;
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}
int main()
{
    int n;
    fac[0]=infac[0]=1;
    for(int i=1;i<=1e5;i++)
    {
        fac[i]=fac[i-1]*i%mod;
        infac[i]=(LL)infac[i - 1] * quick_pow(i,mod-2,mod)%mod;
    }
    cin>>n;
    while(n--)
    {
        int a,b;
        cin>>a>>b;
        cout<<(LL)fac[a] * infac[b] % mod * infac[a - b] % mod<<endl;
    }
}

```

<[G-小红的子序列权值和（hard）_牛客周赛 Round 35 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/76133/G)>

```c++
/*
cnt1 cnt2 cnt3
可以选C(cnt1,i)*C(cnt2,j)*2^cnt1(这之前是子序列的各种组合)*(i+1)*(j+1)（这其中是对子序列的因子数）%p
*/
//C(i,j) = C(i-1,j-1)+C(i,j-1)
/*1
1 1
1 2 1*/
const int p = 1e9+7;
int tong[5];
int n;
// ll C[1010][1010];
//C(n,m) = n!/((n-m)!*m!),
ll jc[100005];

int qmi(ll a,ll b){
	ll res = 1;//a^0
	while(b){
		if(b&1) res = res * a%p;
		b >>= 1;
		a = a*a%p;
	}
	return res;
}
int inv(int x){
	return qmi(x,p-2);
}

ll C(ll n,ll m){
	return jc[n]*inv(jc[n-m])%p*inv(jc[m])%p;
}

int main(){
	cin >> n;
	jc[0] = 1;
	for(int i = 1; i <= n;i++){
		jc[i] = i*jc[i-1]%p;
	}
	
	for(int i = 1; i<= n;i++){
		int x;
		cin >> x;
		tong[x]++;
	}
	
	ll temp = 1;
	ll ans = 0;
	ll c2 = 0,c3 =0;
	for(int i = 1; i<= tong[1];i++) temp = temp * 2 % p;
	
	for(int i = 0; i<= tong[2]; i++){
		c2 += C(tong[2],i)*(i+1)%p;
		c2 %= p;
	}
	for(int i = 0; i<= tong[3]; i++){
		c3 += C(tong[3],i)*(i+1)%p;
		c3 %= p;
	}
	//cout << c2 << " " << c3 << endl;
	ans = c2*c3%p*temp%p;
	cout << ans-1 << endl;
	
}
```



### 求组合数Ⅲ

**适用情况**

当n比较小，组合数特别大时

1 <= n <= 20,1<= b <=a <= 1e18

#### **Lucas定理**

先放结论 $C_a^b($ lucas $) \equiv C_{\frac{a}{p}}^{\frac{b}{p}}($ lucas $) C_{a \bmod p}^{b \bmod p}(\bmod p)$
$$
\begin{gathered}
a=a_k p^k+a_{k-1} p^{k-1}+\ldots+a_0 p^0 \\
b=b_k p^k+b_{k-1} p^{k-1}+\ldots+b_0 p^0-0
\end{gathered}
$$
$$
\begin{aligned}
(1+x)^{p^k} & =C_{p^k}^0 \times 1+C_{p^k}^1 \times x+\ldots+C_{p^k}^{p^k} \times x^{p^k} \\
\left(C_{p^k}^1 \sim C_{p^k}^{p^k-1} \bmod p=0\right) & =1+x^{p^k}(\bmod p)-\emptyset
\end{aligned}
$$
$$
\begin{aligned}
(1+x)^a & =(1+x)^{a_0}\left((1+x)^p\right)^{a_1}\left((1+x)^{p^2}\right)^{a_2} \ldots\left((1+x)^{p^k}\right)^{a_k} \\
\left((1+x)^{p^k}=1+x^{p^k}(\bmod p)-\right.\text { 式) } & =(1+x)^{a_0}\left(1+x^p\right)^{a_1}\left(1+x^{p^2}\right)^{a_2} \ldots\left(1+x^{p^k}\right)^{a_k}(\bmod p) \\
& =C_{a_0}^{b_0} x^{b_0 p^0} \ldots C_{a_{k-1}}^{b_{k-1}} x^{b_{k-1} p^{p^{k-1}}} C_{a_k}^{b_k} x^{b_k p^k}+\text { 其他项 } \\
& =C_{a_0}^{b_0} \ldots C_{a_{k-1}}^{b_{k-1}} C_{a_k}^{b_k} x^{b_k p^k+b_{k-1} p^{k-1}+\ldots+b_0 p^0}+\text { 其他项 } \\
(\text { 式 }) & =C_{a_0}^{b_0} \ldots C_{a_{k-1}}^{b_{k-1}} C_{a_k}^{b_k} x^b+\text { 其他项 }
\end{aligned}
$$
$\therefore$ 有上式中等式左边 $(1+x)^a$ 和右边累乘的 $x^b$ 的系数分别为:
$$
C_a^b \| C_{a_0}^{b_0} \ldots C_{a_{k-1}}^{b_{k-1}} C_{a_k}^{b_k}(\operatorname{modp})
$$

结合(1)可知,
$$
\begin{gathered}
a_0=a \% p, b_0=b \% p \\
a_1=\frac{a}{p} \% p, b_1=\frac{b}{p} \% p \\
\ldots \\
a_k=\frac{a}{p^k} \% p, b_k=\frac{b}{p^k} \% p
\end{gathered}
$$

体现在代码中则只要 $\frac{a}{p}$ 或者 $\frac{b}{p}>p$ 就继续lucas 递归下去直到 $\frac{a}{p}$ 和 $\frac{b}{p}<p$, 递归的过程相当于自上向下将$C_{a_0}^{b_0}->C_{a_k}^{b_k}$添加到乘式里，递归终点为$a_k<p~and~b_k<p$

**代码模板**

```c++
#include<iostream>
#include<algorithm>

using namespace std;

typedef long long LL;

int qmi(int a,int k,int p)
{
    int res = 1;
    while(k)
    {
        if(k&1)res = (LL)res*a%p;
        a = (LL)a*a%p;
        k>>=1;
    }
    return res;
}

int C(int a,int b,int p)//自变量类型int
{
    if(b>a)return 0;//漏了边界条件
    int res = 1;
    // a!/(b!(a-b)!) = (a-b+1)*...*a / b! 分子有b项
    for(int i=1,j=a;i<=b;i++,j--)//i<=b而不是<
    {
        res = (LL)res*j%p;
        res = (LL)res*qmi(i,p-2,p)%p;
    }
    return res;
}
//对公式敲
int lucas(LL a,LL b,int p)
{
    if(a<p && b<p)return C(a,b,p);//lucas递归终点是C_{bk}^{ak}
    return (LL)C(a%p,b%p,p)*lucas(a/p,b/p,p)%p;//a%p后肯定是<p的,所以可以用C(),但a/p后不一定<p 所以用lucas继续递归
}

int main()
{
    int n;
    cin >> n;
    while(n--)
    {
        LL a,b;
        int p;
        cin >> a >> b >> p;
        cout << lucas(a,b,p) << endl;
    }
    return 0;
}

```

### 卡特兰数

**介绍**

学卡特兰数我觉得可能比组合数要难一点，因为组合数可以很明确的告诉你那个公式是在干什么，而卡特兰数却像是在用大量例子来解释什么时卡特兰数
这里，我对卡特兰数做一点自己的理解
卡特兰数是一个在组合数学里经常出现的一个数列，它并没有一个具体的意义，却是一个十分常见的数学规律

对卡特兰数的初步理解：有一些操作，这些操作有着一定的限制，如一种操作数不能超过另外一种操作数，或者两种操作不能有交集等，这些操作的合法操作顺序的数量

为了区分组合数，这里用f（n）表示卡特兰数的第n项
从零开始，卡特兰数的前几项为1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,35357670,129644790…

$$f_n=C_{2n}^{n} - C_{2n}^{n-1}=\frac{C_{2n}^{n}}{n+1}$$

对公式的理解

![1705889438182](C:\Users\肖翰\Downloads\1705889438182.png)

可以抽象成图,可参考

<[卡特兰(Catalan)数入门详解 - Morning_Glory - 博客园 (cnblogs.com)](https://www.cnblogs.com/Morning-Glory/p/11747744.html)>

直接求不好，考虑求有多少种不合法路径
路径总数为在2n次移动中选n次向上移动，即$C_{2n}^{n}$

画一下图，我们把y=x+1这条线画出来，发现所有的合法路径都是不能碰到这条线的，碰到即说明是一条不合法路径
先随便画一条碰到这条线的不合法路径，所有的不合法路径都会与这条线有至少一个交点，我们把第一个交点设为(a,a+1)
如图

![p1.png](C:\Users\肖翰\Downloads\typora\format1,png)

我们把(a,a+1)之后的路径全部按照y=x+1这条线对称过去
这样，最后的终点就会变成(n−1,n+1)

![p2.png](C:\Users\肖翰\Downloads\typora\format,png)

则合法的次数=总次数-不合法的

即$$f_n=C_{2n}^{n} - C_{2n}^{n-1}=\frac{C_{2n}^{n}}{n+1}$$

其中总次数表示一共要走2n步，选其中n步走上就行了

不合法的就是一共要走2n步，选其中n-1步走右边就行了

剩下的n+1步就是往上走

```
#include <bits/stdc++.h>

using namespace std;

typedef long long LL;

const int N = 200010, mod = 1e9 + 7;

int n;
int fact[N], infact[N];

int ksm(int a, int k) {//快速幂求逆元
    int res = 1;
    while (k) {
        if (k & 1) res = (LL)res * a % mod;
        a = (LL)a * a % mod;
        k >>= 1;
    }
    return res;
}

void init() {
    fact[0] = infact[0] = 1;
    for (int i = 1; i < N; i++) {
        fact[i] = (LL)fact[i - 1] * i % mod;
        infact[i] = (LL)infact[i - 1] * ksm(i, mod - 2) % mod;
    }
}

int main() {//用组合数Ⅱ的方法求
    init();
    cin >> n;
    int res = (LL)fact[2 * n] * infact[n] % mod * infact[n] % mod * ksm(n + 1, mod - 2) % mod;
    cout << res << endl;
    return 0;
}

```



## 容斥原理

可参考<[容斥原理 讲解 - Szz - 博客园 (cnblogs.com)](https://www.cnblogs.com/acSzz/archive/2012/11/18/2775923.html)>

![img](C:\Users\肖翰\Downloads\typora\000.png)

### **容斥原理的证明** 

我们要证明下面的等式：

​    ![img](C:\Users\肖翰\Downloads\typora\013.png)

其中B代表全部Ai的集合

​     我们需要证明在Ai集合中的任意元素，都由右边的算式被正好加上了一次（注意如果是不在Ai集合中的元素，是不会出现在右边的算式中的）。

​     假设有一任意元素在k个Ai集合中（k>=1），我们来验证这个元素正好被加了一次：

​     当size(C)=1时，元素x被加了k次。

​     当size(C)=2时，元素x被减了C(2,k)次，因为在k个集合中选择2个，其中都包含x。（这里特别再解释一下，要算被减了多少次，因为减去的是两个集合的交集，而元素x又在k个集合中，因此需要这两个集合是k个集合中的两个才能把元素x包含进去，而在k个集合中选取两个集合次数就是$C_{k}^{2}$

​     当size(C)=3时，元素x被加了C(3,k)次。

​     ……

​     当size(C)=k时，元素x被加/减了C(k,k)次，符号由sign(-1)^(k-1)决定。

​     当size(C)>k时，元素x不被考虑。

​     然后我们来计算所有组合数的和。

​     ![img](https://www.cppblog.com/images/cppblog_com/vici/014.png)

​     由二项式定理，我们可以将它变成：

  ![img](https://www.cppblog.com/images/cppblog_com/vici/015.png)

 

​     我们把x取为1，这时![img](https://www.cppblog.com/images/cppblog_com/vici/0155.png)表示1-T（其中T为x被加的总次数），所以![img](https://www.cppblog.com/images/cppblog_com/vici/0156.png)，证明完毕。

### 容斥原理应用
**样例解释**
$\mathrm{n}=10, p_1=2, p_2=3$, 求 $1-10$ 中能满足能整除 $p_1$ 或 $p_2$ 的个数, 即 $2,3,4,6,8,9,10$, 共 7 个

**解题思路**
记 $S_i$ 为1-n 中能整除 $p_i$ 的集合，那么根据容斥原理,所有数的个数为各个集合的并集，计算公式如下
$$
\bigcup_{i=1}^m S_i=S_1+S_2+\ldots+S_m-\left(S_1 \bigcap S_2+S_1 \bigcap S_3+\ldots+S_{m-1} \bigcap S_m\right)+\left(S_1 \bigcap S_2 \bigcap S_3+.\right.
$$

以题目样例为例
$$
S_1=\{2,4,6,8,10\}, S_2=\{3,6,9\}, S_1 \bigcap S_2=\{6\} \text {, 故 } S_1 \bigcup S_2=\{2,3,4,6,8,9,10\}
$$

**实现思路**

1. 每个集合实际上并不需要知道具体元素是什么，只要知道这个集合的大小，大小为 $\left|S_i\right|=n / p_i$ ，比如题目中 $\left|S_1\right|=10 / 2=5,\left|S_2\right|=10 / 3=3$
2. 交集的大小如何确定? 因为 $p_i$ 均为质数，这些质数的乘积就是他们的最小公倍数，n除这个最小公倍数就是交集的大小，故 $\left|S_1 \bigcap S_2\right|=n /\left(p_1 * p_2\right)=10 /(2 * 3)=1$
3. 如何用代码表示每个集合的状态? 这里使用的二进制，以 $m=4$ 为例，所以需要 4 个二进制位来表示每一个集合选中与不选的状态， $\overbrace{1101}^{m=4}$, 这里表示选中集合 $S_1, S_2, S_4$ ，故这个集合中元素的个数为 $n /\left(p_1 * p_2 * p_4\right)$, 因为集合个数是 3 个，根据公式，前面的系数为 $(-1)^{3-1}=1$ 。所以到当前这个状态时，应该是 $r e s+=n /\left(p_1 * p_2 * p_4\right)$ 。这样就可以表示的范围从 0000 到 1111 的每一个状态
    用二进制表示状态的小技巧非常常用，后面的状态压缩DP也用到了这个技巧，因此一定要掌握

完整代码

<[890. 能被整除的数 - AcWing题库](https://www.acwing.com/problem/content/892/)>

```c++
#include<iostream>
using namespace std;
typedef long long LL;

const int N = 20;
int p[N], n, m;

int main() {
    cin >> n >> m;
    for(int i = 0; i < m; i++) cin >> p[i];

    int res = 0;
    //枚举从1 到 1111...(m个1)的每一个集合状态, (至少选中一个集合)
    //那么就有2^n - 1种状态，可以这么去理解
    //如果在这m位中，出现只要里面有k个1，那就表示是k个集合的交集，所有这些1的的不同组合，就是k个集合的不同组合方式
    因此能遍历到所有状态
    for(int i = 1; i < 1 << m; i++) {
        int t = 1;             //选中集合对应质数的乘积
        int s = 0;             //选中的集合数量

        //枚举当前状态的每一位
        for(int j = 0; j < m; j++){
            //选中一个集合
            if(i >> j & 1){
                //乘积大于n, 则n/t = 0, 跳出这轮循环
                if((LL)t * p[j] > n){    
                    t = -1;
                    break;
                }
                s++;                  //有一个1，集合数量+1
                t *= p[j];
            }
        }

        if(t == -1) continue;  

        if(s & 1) res += n / t;              //选中奇数个集合, 则系数应该是1, n/t为当前这种状态的集合数量
        else res -= n / t;                      //反之则为 -1
    }

    cout << res << endl;
    return 0;
}

```



## 简单博弈论

### NIM游戏

**游戏描述**

若一个游戏满足：

由两名玩家交替行动

1. 在游戏进行的任意时刻，可以执行的合法行动与轮到哪位玩家无关
2. 不能行动的玩家判负
3. 则称该游戏为一个公平组合游戏。

尼姆游戏（NIM）属于公平组合游戏，但常见的棋类游戏，比如围棋就不是公平组合游戏，因为围棋交战双方分别只能落黑子和白子，胜负判定也比较负责，不满足条件2和3。

**题目描述**
给定n堆石子，两位玩家轮流操作，每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），最后无法进行操作的人视为失败。
问如果两人都采用最优策略，先手是否必胜。

例如：有两堆石子，第一堆有2个，第二堆有3个，先手必胜。

操作步骤：
1. 先手从第二堆拿走1个，此时第一堆和第二堆数目相同
2. 无论后手怎么拿，先手都在另外一堆石子中取走相同数量的石子即可。

**必胜状态和必败状态**
在解决这个问题之前，先来了解两个名词:

1. 必胜状态，先手进行某一个操作，留给后手是一个必败状态时，对于先手来说是一个必胜状态。即先手可以走到某一个必败状态。
2. 必败状态，先手无论如何操作，留给后手都是一个必胜状态时，对于先手来说是一个必败状态。即先手走不到任何一个必败状态。

**结论**
假设 $n$ 堆石子，石子数目分别是 $a_1, a_2, \ldots, a_n$ ，如果 $a_1 \oplus a_2 \oplus \ldots \oplus a_n \neq 0$ ，（表示异或）先手必胜；否则先手必败。

证明
- 操作到最后时，每堆石子数都是 $0,0 \oplus 0 \oplus \ldots 0=0$
- 在操作过程中，如果 $a_1 \oplus a_2 \oplus \ldots \oplus a_n=x \neq 0$ 。那么玩家必然可以通过拿走某一堆若干个石子将异或结果变为 0 。
证明: 不妨设 $x$的二进制表示中最高一位 1 在第 $\mathrm{k}$ 位，那么在 $a_1, a_2, \ldots, a_n$ 中，必然有一个数 $a_i$ ，它的第 $\mathrm{k}$ 为时 1 ，且 $a_i \oplus x<a_i$, 那么从第 $i$ 堆石子中拿走 $\left(a_i-a_i \oplus x\right)$ 个石子，第 $i$ 堆石子还剩 $a_i-\left(a_i-a_i \oplus x\right)=a_i \oplus x$ ，此时 $a_1 \oplus a_2 \oplus \ldots \oplus a_i \oplus x \oplus \ldots \oplus a_n=x \oplus x=0$.
- 在操作过程中，如果 $a_1 \oplus a_2 \oplus \ldots \oplus a_n=0$ ，那么无论玩家怎么拿，必然会导致最终异或结果不为 0 。反证法: 假设玩家从第 $i$ 堆石子拿走若干个，结果仍是 0 。不妨设还剩下 $a^{\prime}$ 个，因为不能不拿，所以 $0 \leq a^{\prime}<a_i$ ，且 $a_1 \oplus a_2 \oplus \ldots \oplus a^{\prime} \oplus \ldots \oplus a_n=0$ 。那么
$\left(a_1 \oplus a_2 \oplus \ldots \oplus a_i \oplus \ldots a_n\right) \oplus\left(a_1 \oplus a_2 \oplus \ldots \oplus a^{\prime} \oplus \ldots \oplus a_n\right)=a_i \oplus a^{\prime}=0$ ，则 $a_i=a^{\prime}$ ，与假设 $0 \leq a^{\prime}<a_i$ 矛盾。

基于上述三个证明:

如果先手面对的局面是 $a_1 \oplus a_2 \oplus \cdots \oplus a_n \neq 0$ ，那么先手总可以通过拿走某一堆若干个石子，将局面变成 $a_1 \oplus a_2 \oplus \ldots \oplus a_n=0$ 。如此重复，最后一定是后手面临最终没有石子可拿的状态。先手必胜。 2. 如果先手面对的局面是 $a_1 \oplus a_2 \oplus \ldots \oplus a_n=0$ ，那么无论先手怎么拿，都会将局面变成 $a_1 \oplus a_2 \oplus \ldots \oplus a_n \neq 0$ ，那么后手总可以通过拿走某一堆若干个石子，将局面变成 $a_1 \oplus a_2 \oplus \ldots \oplus a_n=0$ 。 如此重复，最后一定是先手面临最终没有石子可拿的状态。先手必败。

```c++
#include <iostream>
#include <cstdio>
using namespace std;

/*
先手必胜状态：先手操作完，可以走到某一个必败状态
先手必败状态：先手操作完，走不到任何一个必败状态
先手必败状态：a1 ^ a2 ^ a3 ^ ... ^an = 0
先手必胜状态：a1 ^ a2 ^ a3 ^ ... ^an ≠ 0
*/

int main(){
    int n;
    scanf("%d", &n);
    int res = 0;
    for(int i = 0; i < n; i++) {
        int x;
        scanf("%d", &x);
        res ^= x;
    }
    if(res == 0) puts("No");
    else puts("Yes");
}

```



### 有向图游戏
给定一个有向无环图，图中有一个唯一的起点，在起点上放有一枚棋子。两名玩家交替地把这枚棋子沿有向边进行移动，每次可以移动一步，无法移动者判负。该游戏被称为有向图游戏。
任何一个公平组合游戏都可以转化为有向图游戏。具体方法是，把每个局面看成图中的一个节点，并且从每个局面向沿着合法行动能够到达的下一个局面连有向边。

### Mex运算
设S表示一个非负整数集合。定义mex(S)为求出不属于集合S的最小非负整数的运算，即：
mex(S) = min{x}, x属于自然数，且x不属于S

### SG函数
在有向图游戏中，对于每个节点x，设从x出发共有k条有向边，分别到达节点y1, y2, …, yk，定义SG(x)为x的后继节点y1, y2, …, yk 的SG函数值构成的集合再执行mex(S)运算的结果，即：
**SG(x) = mex({SG(y1), SG(y2), …, SG(yk)})**
特别地，整个有向图游戏G的SG函数值被定义为有向图游戏起点s的SG函数值，即SG(G) = SG(s)。

**有向图游戏的和 —— 模板题 AcWing 893. 集合-Nim游戏**
设G1, G2, …, Gm 是m个有向图游戏。定义有向图游戏G，它的行动规则是任选某个有向图游戏Gi，并在Gi上行动一步。G被称为有向图游戏G1, G2, …, Gm的和。
有向图游戏的和的SG函数值等于它包含的各个子游戏SG函数值的异或和，即：
**SG(G) = SG(G1) ^ SG(G2) ^ … ^ SG(Gm)**

**性质**

1. $S(G) = k$,则$i$能最大能到达的点的$SG$值为$k-1$
2. 非0可以走向0（因为如果$S(G) ！=0$那么说明一定 有一个数可以走到0，不然$S(G)$就会等于0了
3. 0只能走向非0

**定理**
有向图游戏的某个局面必胜，当且仅当该局面对应节点的SG函数值大于0。
有向图游戏的某个局面必败，当且仅当该局面对应节点的SG函数值等于0。

完整代码<[893. 集合-Nim游戏 - AcWing题库](https://www.acwing.com/problem/content/description/895/)>

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<set>

using namespace std;

const int N=110,M=10010;
int n,m;
int f[M],s[N];//s存储的是可供选择的集合,f存储的是所有可能出现过的情况的sg值

int sg(int x)
{
    if(f[x]!=-1) return f[x];
    //因为取石子数目的集合是已经确定了的,所以每个数的sg值也都是确定的,如果存储过了,直接返回即可
    set<int> S;
    //set代表的是有序集合(注:因为在函数内部定义,所以下一次递归中的S不与本次相同)
    for(int i=0;i<m;i++)
    {
        int sum=s[i];
        if(x>=sum) S.insert(sg(x-sum));
        //先延伸到终点的sg值后,再从后往前排查出所有数的sg值
    }

    for(int i=0;;i++)
    //循环完之后可以进行选出最小的没有出现的自然数的操作
     if(!S.count(i))
      return f[x]=i;//这一步也可以看成Mex运算
}

int main()
{
    cin>>m;
    for(int i=0;i<m;i++)
    cin>>s[i];

    cin>>n;
    memset(f,-1,sizeof(f));//初始化f均为-1,方便在sg函数中查看x是否被记录过

    int res=0;
    for(int i=0;i<n;i++)
    {
        int x;
        cin>>x;
        res^=sg(x);
        //观察异或值的变化,基本原理与Nim游戏相同
    }

    if(res) printf("Yes");
    else printf("No");

    return 0;
}


```

**样例理解SG函数**

 让我们通过一个简单的例子来理解 `sg` 函数的工作原理。假设我们有一个石子游戏，游戏中有 3 个石子，每个石子可以取 1 到 3 个石子。现在，我们要计算石子数目为 2 的所有可能组合的 SG 值。

首先，我们定义 `s` 数组，它包含了所有可供选择的石子数目。在这个例子中，`s` 数组可以是 `{1, 2, 3}`。

现在，我们来计算 `sg(2)` 的值。根据 `sg` 函数的逻辑：

1. 我们首先检查 `f[2]` 是否已经计算过。如果没有，我们继续。
2. 创建一个空的集合 `S`。
3. 遍历 `s` 数组：
   - 当 `i = 0` 时，`s[0] = 1`。因为 `2 >= 1`，我们递归调用 `sg(2 - 1)`，得到 `sg(1)` 的值，然后将其插入到集合 `S` 中。
   - 当 `i = 1` 时，`s[1] = 2`。因为 `2 >= 2`，我们递归调用 `sg(2 - 2)`，得到 `sg(0)` 的值，然后将其插入到集合 `S` 中。
   - 当 `i = 2` 时，`s[2] = 3`。因为 `2 < 3`，我们不进行任何操作。
4. 在集合 `S` 中，我们可能已经有了 `sg(1)` 和 `sg(0)` 的值。我们需要找到一个最小的自然数，这个数不在 `S` 中。假设 `sg(1)` 是 3，`sg(0)` 是 1，那么最小的未出现的自然数是 2。我们返回这个值，并将其存储在 `f[2]` 中。

现在，`f[2]` 存储了 `sg(2)` 的值，即 2。这个值代表了所有可能的石子组合（在这个例子中，可能是取 1 个石子和 1 个石子，或者取 2 个石子）的 SG 值。

在实际的石子游戏中，我们可能会有更复杂的规则，比如每次只能取特定数目的石子，或者有特定的取石子顺序。`sg` 函数的逻辑可以根据这些规则进行调整，以计算出正确的 SG 值。在解决这类问题时，关键在于理解如何通过递归和集合来探索所有可能的组合，并找到满足特定条件的最小值。

# 动态规划

**动规五部曲**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

**一些思考：**

维数可以先从低维考虑起

一般对末状态进行思考，看有几种状态，分别分析这几种状态如何来的

动态规划本质也是一种暴力，可以从暴力的角度思考，如何得出子问题                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  （优化过的暴力）

<[动态规划 - 标签 - chanxe - 博客园 (cnblogs.com)](https://www.cnblogs.com/chanxe/tag/动态规划/)>有一些y总的分析方法

## 背包问题

![416.分割等和子集1](C:\Users\肖翰\Downloads\typora\20210117171307407.png)

### 01背包问题

1. **题目介绍**

有 $N$ 件物品和一个容量为 $V$ 的背包，每件物品有各自的价值且只能被选择一次，要求在有限的背包容量下，装入的物品总价值最大。

「0-1 背包」是较为简单的动态规划问题，也是其余背包问题的基础。
动态规划是不断决策求最优解的过程，「0-1 背包」即是不断对第 $i$ 个物品的做出决策，「0-1」正好代表不选与选两种决定。

2. **题解代码 (C++)**
**版本1 二维**
(1) 状态 $\mathrm{f}[\mathrm{i}][\mathrm{j}]$ 定义：前 $i$ 个物品，背包容量 $j$ 下的最优解 (最大价值) :
- 当前的状态依赖于之前的状态，可以理解为从初始状态 $f[\theta][\theta]=0$ 开始决策，有 $N$ 件物品，则需要 $N$ 次决 策，每一次对第 $i$ 件物品的决策，状态 $f[i][j]$ 不断由之前的状态更新而来。
（2）当前背包容量不够（ $j<v[i]$ ），没得选，因此前 $i$ 个物品最优解即为前 $i-1$ 个物品最优解:
- 对应代码: $f[i][j]=f[i-1][j]$ 。
（3）当前背包容量够，可以选，因此需要决策选与不选第 $i$ 个物品:
- 选: $f[i][j]=f[i-1][j-v[i]]+w[i]$ 。
- 不选: $f[i][j]=f[i-1][j]$ 。
- 我们的决策是如何取到最大价值，因此以上两种情况取 $\max ()$ 。

**代码模板**

```c++
#include<bits/stdc++.h>

using namespace std;

const int MAXN = 1005;
int v[MAXN];    // 体积
int w[MAXN];    // 价值 
int f[MAXN][MAXN];  // f[i][j], j体积下前i个物品的最大价值 

int main() 
{
    int n, m;   
    cin >> n >> m;
    for(int i = 1; i <= n; i++) 
        cin >> v[i] >> w[i];

    for(int i = 1; i <= n; i++) 
        for(int j = 1; j <= m; j++)
        {
            //  当前背包容量装不进第i个物品，则价值等于前i-1个物品
            if(j < v[i]) 
                f[i][j] = f[i - 1][j];
            // 能装，需进行决策是否选择第i个物品
            else    
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
        }           

    cout << f[n][m] << endl;

    return 0;
}

```



**优化为一维**

在使用二维数组的时候，递推公式：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

**二维转化为一维：**
删掉了第一维：在前i个物品中取。
f[j]表示：拿了总体积不超过j的物品，最大总价值。

**为何能转化为一维？**
二维时的更新方式：f[i][j]=max(f[i - 1][j] ,f[i - 1][j - v[i]] + w[i]);
1.我们发现，对于每次循环的下一组i，只会用到i-1来更新当前值，不会用到i-2及之前值。于是可以在这次更新的时候，将原来的更新掉，反正以后也用不到。
所以对于i的更新，只需用一个数组，直接覆盖就行了。
2.我们发现，对于每次j的更新，只需用到之前i-1时的j或者j-v[i]，不会用到后面的值。
所以为了防止串着改，我们采取从后往前更新的方式，用原来i-1的数组来更新i。
（如果从前往后更新的话，前面的更新过之后，会接着更新后面的值，这样就不能保证是用原来i-1的数组来更新i的了（因为i-1可能别i-1上的值覆盖了，故这样会影响后面的值））

**如何转化为一维呢？**
只用一个数组，每次都**覆盖**前面的数组。

1.如果当前位置的东西不拿的话，和前一位置的信息（原来i-1数组的这个位置上的值）是相同的，所以不用改变。
2.如果当前位置的东西拿了的话，需要和前一位置的信息（原来i-1数组的这个位置上值）取max。
所以，更新方式就为：f[j]=max(f[j],f[j-v[i]]+w[i]);

整个更新方式就相当于：

每次i++，就从后往前覆盖一遍f数组，看每个位置上的值是否更新。

具体还可参考<[代码随想录 (programmercarl.com)](https://www.programmercarl.com/背包理论基础01背包-2.html#思路)>

**代码模板**

```c++
#include<bits/stdc++.h>

using namespace std;

const int MAXN = 1005;
int f[MAXN];  // 

int main() 
{
    int n, m;   
    cin >> n >> m;

    for(int i = 1; i <= n; i++) {
        int v, w;
        cin >> v >> w;      // 边输入边处理
        for(int j = m; j >= v; j--)//注意要改变遍历顺序，从后往前
            f[j] = max(f[j], f[j - v] + w);
    }

    cout << f[m] << endl;

    return 0;
}

```



### 完全背包问题

在01背包的基础上，此时物品变为无限个

![image-20240125141505367](C:\Users\肖翰\Downloads\typora\image-20240125141505367.png)

**代码模板**

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int f[N][N];
int v[N],w[N];//v表示体积，w表示权值
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i = 1 ; i <= n ;i ++)
    {
        cin>>v[i]>>w[i];
    }

    for(int i = 1 ; i<=n ;i++)
    for(int j = 0 ; j<=m ;j++)
    {
        for(int k = 0 ; k*v[i]<=j ; k++)
            f[i][j] = max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);//遍历物品i的数量，直到大于背包容量
    }

    cout<<f[n][m]<<endl;
}

```

**优化思路**

```c++
f[i , j ] = max( f[i-1,j] , f[i-1,j-v]+w ,  f[i-1,j-2*v]+2*w , f[i-1,j-3*v]+3*w , .....)
f[i , j-v]= max(            f[i-1,j-v]   ,  f[i-1,j-2*v] + w , f[i-1,j-3*v]+2*w , .....)
由上两式，可得出如下递推关系： 
                        f[i][j]=max(f[i,j-v]+w , f[i-1][j]) 
```

**模拟过程**

```c++
首先dp数组初始化全为0：给定物品种类有4种，包最大体积为5，数据来源于题目的输入
v[1] = 1, w[1] = 2
v[2] = 2, w[2] = 4
v[3] = 3, w[3] = 4
v[4] = 4, w[4] = 5

i = 1 时： j从v[1]到5
dp[1] = max(dp[1],dp[0]+w[1]) = w[1] = 2 (用了一件物品1）
dp[2] = max(dp[2],dp[1]+w[1]) = w[1] + w[1] = 4（用了两件物品1）
dp[3] = max(dp[3],dp[2]+w[1]) = w[1] + w[1] + w[1] = 6（用了三件物品1）
dp[4] = max(dp[4],dp[3]+w[1]) = w[1] + w[1] + w[1] + w[1] = 8（用了四件物品1）
dp[5] = max(dp[3],dp[2]+w[1]) = w[1] + w[1] + w[1] + w[1] + w[1] = 10（用了五件物品）
                                          
                                     

i = 2 时：j从v[2]到5
dp[2] = max(dp[2],dp[0]+w[2]) = w[1] + w[1] = w[2] =  4（用了两件物品1或者一件物品2）
dp[3] = max(dp[3],dp[1]+w[2]) = 3 * w[1] = w[1] + w[2] =  6（用了三件物品1，或者一件物品1和一件物品2）
dp[4] = max(dp[4],dp[2]+w[2]) = 4 * w[1] = dp[2] + w[2] =  8（用了四件物品1或者，两件物品1和一件物品2或两件物品2）
dp[5] = max(dp[5],dp[3]+w[2]) = 5 * w[1] = dp[3] + w[2] =  10（用了五件物品1或者，三件物品1和一件物品2或一件物品1和两件物品2）

i = 3时：j从v[3]到5
dp[3] = max(dp[3],dp[0]+w[3]) = dp[3] = 6 # 保持第二轮的状态 
dp[4] = max(dp[4],dp[1]+w[3]) = dp[4] = 8 # 保持第二轮的状态 
dp[5] = max(dp[5],dp[2]+w[3]) = dp[4] = 10 # 保持第二轮的状态

i = 4时：j从v[4]到5
dp[4] = max(dp[4],dp[0]+w[4]) = dp[4] = 10 # 保持第三轮的状态
dp[5] = max(dp[5],dp[1]+w[4]) = dp[5] = 10 # 保持第三轮的状态

上面模拟了完全背包的全部过程，也可以看出，最后一轮的dp[m]即为最终的返回结果。


```

i=1时，计算只放第一件物品的最大价值。

i=2时，计算加上第二件物品的最大价值（在只放第一件物品的前提下）

以此类推……

值得注意的是，第二层循环要从j=weight[i]开始（j起码要能放进i这个物品，放不进就进入不了循环，f也不会更新），这个稍微理解一下即可。

![img](C:\Users\肖翰\Downloads\typora\1234089-20171029193204805-153439260.png)

**代码模板**

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int f[N];//表示背包容量为N
int v[N],w[N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i = 1 ; i <= n ;i ++)
    {
        cin>>v[i]>>w[i];
    }

    for(int i = 1 ; i<=n ;i++)
    for(int j = v[i] ; j<=m ;j++)//顺序是从大到小跟01背包不一样，
    {
            f[j] = max(f[j],f[j-v[i]]+w[i]);
    }
    cout<<f[m]<<endl;
}


```

### 多重背包

现01背包的基础上，现在物品有了最大数量

**暴力写法**

```c++
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 110;

int v[N], w[N], s[N];
int f[N][N];
int n, m;

int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) cin >> v[i] >> w[i] >> s[i];

    for(int i = 1; i <= n; i ++){//枚举背包
        for(int j = 1; j <= m; j ++){//枚举体积
            for(int k = 0; k <= s[i]; k ++){
                if(j >=  k * v[i]){
                    f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + k * w[i]);
                }
            }
        }
    }

    cout << f[n][m] << endl;

    return 0;
}

```

**优化思路**

通过将物品的数量用二进制分成不同的堆，这几个堆又可以看成一个01背包问题

**为什么不能像完全背包那样优化？**

[(40 封私信 / 2 条消息) 为什么多重背包不能用完全背包的优化思路？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/444834258)
$$
\begin{aligned}
& f[i, j]=\max (f[i-1, j], f[i-1, j-v]+w, f[i-1, j-2 v]+2 w, \ldots f[i-1, j-S v]+S w,) \\
& f[i, j-v]=\max (f[i-1, j-v], f[i-1, j-2 v]+w, \ldots \ldots f[i-1, j-S v]+(S-1) w \\
& f[i-1, j-(S+1) v]+S w)
\end{aligned}
$$

**怎么比完全背包方程比较就多出了一项?**
其实，一般从实际含义出发来考虑即可，这里是在分析 $f[i, j-w]$ 这个状态的表达式，首先这个状态的含义是从前 $\mathrm{i}$ 个物品中选，且总体积不超过 $\mathrm{j}-\mathrm{w}$ 的最大价值，我们现在最多只能选 $\mathrm{s}$ 个物品，因此如果我们选 $\mathrm{s}$ 个第门个物品，那么体积上就要减去 $s * v$, 价值上就要加上 $s * w$ ，那更新到状态中去就是
$$
f[i-1, j-v-s * v]+s * w
$$
而不能通过这个的最大值求出前n项的最大值

<[y总算法基础课视频 4分10秒-5分42秒](https://www.acwing.com/video/326/)>

**如何优化呢**

我们首先确认三点：

（1）我们知道转化成01背包的基本思路就是判断我是取了你好呢还是不取你好。

（2）我们知道任意一个实数可以由二进制数来表示，也就是2^0~2^k其中一项或几项的和。

（3）这里多重背包问的就是每件物品取多少件可以获得最大价值。

三者综合，然后在纸上深究一下，大概就能理解了。

如果直接遍历转化为01背包问题，是每次都拿一个来问，取了好还是不取好，假如10个取7个好，那么在实际的遍历过程中在第七个以后经过状态转移方程其实已经是选择“不取”好了，现在，用二进制思想将其分堆，分成k+1个分别有2^k^个的堆，然后拿这一堆一堆去问，我是取了好呢，还是不取好呢，经过dp选择之后，结果和拿一个一个来问的结果是完全一样的，因为dp选择的是最优结果，而根据第二点任意一个实数都可以用二进制来表示，如果最终选出来10个取7个是最优的在分堆的选择过程中分成了2^0^=1,2^1^=2,2^2^=4,2^3^=8这四堆，然后去问四次，也就是拿去走dp状态转移方程，走的结果是第一堆1个，取了比不取好，第二堆2个，取了比不取好，第三堆四个，取了比不取好，第四堆8个，取了还不如不取，最后依旧是取了1+2+4=7个，为什么是这样呢？因为dp本身就是用来比较哪个更优的，在状态转移的过程中自然会完成上述询问得出相应结果。这也就是说，无论最终取几个是最优解，用二进制取出来的结果和一次一次问是完全一样的。

参考<[背包问题的二进制优化_二进制优化很神奇-CSDN博客](https://blog.csdn.net/qq_33171970/article/details/50582671)>

**优化后代码**

```
#include<iostream>
using namespace std;

const int N = 12010, M = 2010;

int n, m;
int v[N], w[N]; //逐一枚举最大是N*logS
int f[M]; // 体积<M

int main()
{
    cin >> n >> m;
    int cnt = 0; //分组的组别
    for(int i = 1;i <= n;i ++)
    {
        int a,b,s;
        cin >> a >> b >> s;
        int k = 1; // 组别里面的个数
        while(k<=s)
        {
            cnt ++ ; //组别先增加
            v[cnt] = a * k ; //整体体积
            w[cnt] = b * k; // 整体价值
            s -= k; // s要减小
            k *= 2; // 组别里的个数增加
        }
        //剩余的一组
        if(s>0)
        {
            cnt ++ ;
            v[cnt] = a*s; 
            w[cnt] = b*s;
        }
    }

    n = cnt ; //枚举次数正式由个数变成组别数

    //01背包一维优化
    for(int i = 1;i <= n ;i ++)
        for(int j = m ;j >= v[i];j --)
            f[j] = max(f[j],f[j-v[i]] + w[i]);
            //第一次就遍历了第一种物品取小于最大数量的各种取法
            //这里为什么要倒序呢，因为用来01背包的优化版本

    cout << f[m] << endl;
    return 0;
}

```

### 分组背包

在01背包的基础上进行了分组，每组只能选一个物品，物品也是只能选一次

**二维写法**

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=110;
int f[N][N];  //只从前i组物品中选，当前体积小于等于j的最大值
int v[N][N],w[N][N],s[N];   //v为体积，w为价值，s代表第i组物品的个数
int n,m,k;

int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>s[i];
        for(int j=0;j<s[i];j++){
            cin>>v[i][j]>>w[i][j];  //读入
        }
    }

    for(int i=1;i<=n;i++){
        for(int j=0;j<=m;j++){
            f[i][j]=f[i-1][j];  //不选
            for(int k=0;k<s[i];k++){//在第i组中选一个，遍历第i组的每一个物品，取最大值
                if(j>=v[i][k])     f[i][j]=max(f[i][j],f[i-1][j-v[i][k]]+w[i][k]);  
            }
        }
    }
    cout<<f[n][m]<<endl;
}


```

一维优化后

```c++
#include<bits/stdc++.h>
using namespace std;

const int N=110;
int f[N];
int v[N][N],w[N][N],s[N];
int n,m,k;

int main(){
    cin>>n>>m;
    for(int i=0;i<n;i++){
        cin>>s[i];
        for(int j=0;j<s[i];j++){
            cin>>v[i][j]>>w[i][j];
        }
    }

    for(int i=0;i<n;i++){
        for(int j=m;j>=0;j--){//在这里换一下遍历顺序，思路跟01背包的压缩方式一样
            for(int k=0;k<s[i];k++){    //for(int k=s[i];k>=1;k--)也可以
                if(j>=v[i][k])     f[j]=max(f[j],f[j-v[i][k]]+w[i][k]);  
            }
        }
    }
    cout<<f[m]<<endl;
}

```



## 线性DP

#### 概念

很多问题往往会给出一个序列或者一个数表，让你对其进行划分，或者选出其中的某个最优子集。这一类问题往往适合使用线性DP。
线性DP是一种非常常见的DP。它往往以状态内的其中一个维度划分阶段。接下来，我将给出几个非常重要的转移方程。

参考<[线性DP - LinearODE - 博客园 (cnblogs.com)](https://www.cnblogs.com/LinearODE/p/11589127.html)>

<[897. 最长公共子序列 - AcWing题库](https://www.acwing.com/problem/content/description/899/)>

![1706088302384](C:\Users\肖翰\Downloads\1706088302384.png)

为什么状态转移是这个呢？

1. 这四种情况能遍历所有情况（可以重复，不能漏选）
2. 可以不考虑f[i-1，j-1]因为f[i-1,j]和f[i,j-1]包含了这种情况
3. 为什么不是f[i-2,j]或者其他的，因为要包含所有情况，相邻两个数才能包含所有情况

状态是怎么转移的呢，我们发现从i和j都是从小到大枚举，也就是保证了当前的i = 1，的时候就将问题分解成最小的子问题，一个字符与一个字符串的最长公共子序列，那当i慢慢递增的时候呢，我都可以依靠前面的结果，比如i = 3时，如果与对于的j不相等，那么最长公共子序列就是前面我算出来过的，经过不断递推，最终得到两个字符串的最长公共子序列

```c++
#include <iostream>
using namespace std;
const int N = 1010;
int n, m;
char a[N], b[N];
int f[N][N];
int main() {
  cin >> n >> m >> a + 1 >> b + 1;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      if (a[i] == b[j]) {
        f[i][j] = f[i - 1][j - 1] + 1;
      } else {
        f[i][j] = max(f[i - 1][j], f[i][j - 1]);//包含了前面的所有情况的最优解，求一个max就是f[i][j]的最优解
      }
    }
  }
  cout << f[n][m] << '\n';
  return 0;
}

```





## 区间DP

#### **概念**

区间类型动态规划是线性动态规划的拓展，它在分阶段划分问题时，与阶段中元素出现的顺序和由前一阶段的哪些元素合并而来有很大的关系。（例：f[i][j]=f[i，k]+f[k+1，j]）

区间类动态规划的特点：

- 合并：即将两个或多个部分进行整合。
- 特征：能将问题分解成为两两合并的形式。
- 求解：对整个问题设最优值，枚举合并点，**将问题分解成为左右两个部分，**最后将左右两个部分的最优值进行合并得到原问题的最优值。

一般先枚举区间长度，然后加左端点，右端点自然就是len-左端点+1

再考虑递推关系

例题<[282. 石子合并 - AcWing题库](https://www.acwing.com/problem/content/284/)>

```c++
#include <iostream>
#include <cstring>

using namespace std;

const int N = 307;

int a[N], s[N];
int f[N][N];

int main() {
    int n;
    cin >> n;

    for (int i = 1; i <= n; i ++) {
        cin >> a[i];
        s[i] += s[i - 1] + a[i];
    }

    memset(f, 0x3f, sizeof f);
    // 区间 DP 枚举套路：长度+左端点 
    for (int len = 1; len <= n; len ++) { // len表示[i, j]的元素个数
        for (int i = 1; i + len - 1 <= n; i ++) {
            int j = i + len - 1; // 自动得到右端点
            if (len == 1) {
                f[i][j] = 0;  // 边界初始化
                continue;
            }

            for (int k = i; k <= j - 1; k ++) { // 必须满足k + 1 <= j
                f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1]);
            }
        }
    }

    cout << f[1][n] << endl;


    return 0;
}

```

#### 代码模板

```c++
for(int i=2;i<=len;i++)//枚举区间长度
{
	for(int l=1,r=l+len-1;r<=n;l++,r++)//枚举左端点和右端点
	{
		//以下你可以搞一下事情
		for(int k=l;k<r;k++)
		{
			//以下你还可以搞一下事情
			dp[l][r]=max(dp[l][r],dp[l][k]+dp[k+1][r]); 
		 } 
	}
}

```

例题<[F-矩阵取数游戏_Part5.1 动态规划-区间类动态规划 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/971/F)>

## 计数类DP

#### 概念

> 此类问题一般要我们求解方案数
> 根据题目描述，可以分为组合数和排列数问题
> 一般套路是转化为背包问题

例题：<[900. 整数划分 - AcWing题库](https://www.acwing.com/problem/content/902/)>

考虑转化为完全背包问题

**初值问题:**
求最大值时，当都不选时，价值显然是 0
而求方案数时，当都不选时，方案数是 1 (即前 $\mathrm{i}$ 个物品都不选的情况也是一种方案)，所以需要初始化为 1
即: for (int $i=0$; $i<=n$; $i++$ ) $f[i][0]=1$;
等价变形后: $f[0]=1$
**状态计算:**
$f[i][j]$ 表示前 $\mathrm{i}$ 个整数 $(1,2 \ldots, \mathrm{i})$ 恰好拼成 $\mathrm{j}$ 的方案数
求方案数：把集合选 0 个 $i, 1$ 个 $i ， 2$ 个 $i ， \ldots$ 全部加起来
$$
\begin{aligned}
& f[i][j]=f[i-1][j]+f[i-1][j-i]+f[i-1][j-2 * i]+\ldots ; \\
& f[i][j-i]=f[i-1][j-i]+f[i-1][j-2 * i]+\ldots ;
\end{aligned}
$$

因此 $f[i][j]=f[i-1][j]+f[i][j-i]$; (这一步类似完全背包的推导)

代码

```c++
#include <iostream>

using namespace std;


typedef long long LL ;

const int mod = 1e9+7;

const int N = 1010;

int f[N][N] ;
//从前面的i个物品当中选质量恰为j的重量的方法数

int main()
{
    int n ; 
    cin >> n ; 

    //二维
    for(int i = 0 ; i <= n ; i++)
        f[i][0] = 1;

    for(int i = 1 ; i <= n ; i++ ){
        for(int j = 0 ; j <= n ; j++ ){ //j >= i
            if(j >= i )
                f[i][j] = (f[i-1][j] + f[i][j-i])%mod;
            else    
                f[i][j] = f[i-1][j] ;
        }
    }

    //一维
    /*
    f[0] = 1;

    for(int i = 1 ; i <= n ; i++ )
        for(int j = 0 ; j <= n ; j++ )
            f[j] = (f[j] + f[j-i])%mod;

    cout << f[n] << endl;
    */
    cout << f[n][n] << endl;

    return 0;
}

```

*DP*并不是全都有max,min函数的啊，DP的核心其实是从上一层的最优解推下一层的最优解，但这个题的最优即所有方案加起来的和，所以这个题没有取max,min。

## 数位统计DP

#### 概念

数位dp,是一种用来计数的dp

如果现在给你一道题,需要你求在区间[l,r]内满足条件的解的个数,我们很容易想到去暴力枚举,但要是数据范围太大这种办法就行不通了,这时候数位dp就派上了用场,所谓数位就是把一个数拆成一个一个进制位,对其每一上的位数进行操作然后逐一比较看是否满足题目要求,这其实也是一种暴力方法,只不过时间复杂度小了很多

一道典型例题<[Problem - 2089 (hdu.edu.cn)](https://acm.hdu.edu.cn/showproblem.php?pid=2089)>

<[AcWing 1085. 不要62_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1Zc411C7mF/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=e03b7d988550b29e55118b7d8e6cab3c)>

**思路分析**

设f[i,j]表示前i为，最高位是j的数量（以后数位dp一般是这样假设，前人总结出的规律）

考虑这个集合，要求满足要求的数量，那么我们就枚举各种情况，比如再增加一维，枚举i-1这一位的数字，看看满不满足，如果满足，那么就加上这个f的数量,那要怎么遍历完所有情况呢，

比如f（5，4）表示400000～499999
f[3，1]=f[2，0]+f[2，1]+f[2，2]+f[2，3]+f[2,4]+f[2，5]+f[2，6]+f[2，7]+f[2，8]+f[2，9] 
f（i，0）就能表示那些小的数

考虑递推方程f[i,j] = f[i,j] + f[i-1]+k(这样就能遍历到所有情况，再把满足情况的加进来)

**完整代码**

```
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;
const int N = 11;
int f[N][N];
int a, b;
void init()
{
    for (int i = 0; i <= 9; i ++)
        if (i != 4)
            f[1][i] = 1;//初始化，0~9中除了4都满足情况，个数为1

    for (int i = 2; i < N; i ++)//位数从第二位开始
        for (int j = 0; j <= 9; j ++)//位数的最大值是多少
            for (int k = 0; k <= 9; k ++)
            {    
                if (j == 4 || k == 4) continue;
                if (j == 6 && k == 2) continue;
                f[i][j] += f[i - 1][k];//满足情况就加入进来
            }   
}
int dp(int n)
{
    if (!n) return 1;

    vector<int> nums;
    while (n) nums.push_back(n % 10), n /= 10;

    int res = 0;
    int last = 0;//表示上一个数

    for (int i = nums.size() - 1; i >= 0; i --)
    {//从高位枚举
        int x = nums[i];//表示当前的数
        for (int j = 0; j < x; j ++)
            if (j == 4 || last == 6 && j == 2) continue;
            else res += f[i + 1][j];//加入到res中，这个肯定能遍历到所有情况，并且不重复，我上面有解释，i+1表示位数，因为数组下标是从0开始的

        if (last == 6 && x == 2 || x == 4) break;
        last = x;

        if (!i) res ++;//当i是第0位时（因为数组下标是从0开始的）res只加一个
    }
    return res;
}
int main()
{
    init();
    while (cin >> a >> b, a || b)
        cout << dp(b) - dp(a - 1) << endl;//前缀和的思想，求[a,b]这个区间
    return 0;
}

```



## 状态压缩DP

#### 概念

**什么是状压DP：**
动态规划的状态有时候比较恶心，不容易表示出来，需要用一些编码技术，把状态压缩的用简单的方式表示出来。
典型方式：当需要表示一个集合有哪些元素时，往往利用2进制用一个整数表示。
动态规划本来就很抽象，状态的设定和状态的转移都不好把握，而状态压缩的动态规划解决的就是那种状态很多，不容易用一般的方法表示的动态规划问题，这个就更加的难于把握了。难点在于以下几个方面：状态怎么压缩？压缩后怎么表示？怎么转移？是否具有最优子结构？是否满足后效性？涉及到一些位运算的操作，虽然比较抽象，但本质还是动态规划。找准动态规划几个方面的问题，深刻理解动态规划的原理，开动脑筋思考问题。这才是掌握动态规划的关键。

参考<[状态压缩DP入门 - iBilllee - 博客园 (cnblogs.com)](https://www.cnblogs.com/ibilllee/p/7651971.html)>

**分析**

| 运算名 | 符号     | 效果                                                         |
| ------ | -------- | ------------------------------------------------------------ |
| &      | 按位与   | 如果两个相应的二进制位都为1，则该位的结果值为1，否则为0      |
| l      | 按位或   | 两个相应的二进制位中只要有一个为1，该位的结果值为1           |
| ^      | 按位异或 | 若参加运算的两个二进制位值相同则为0，否则为1                 |
| ~      | 取反     | ~是一元运算符，用来对一个二进制数按位取\反，即将0变1，将1变0 |
| <<     | 左移     | 用来将一个数的各二进制位全部左移N位，右补0                   |
| *>>    | 右移     | 将一个数的各二进制位右移N位，移到右端 的低位被舍弃，对于无符号数，高位补0 |

例题<[291. 蒙德里安的梦想 - AcWing题库](https://www.acwing.com/problem/content/293/)>

解析<[AcWing 291. 蒙德里安的梦想 - AcWing](https://www.acwing.com/solution/content/28088/)>



完整代码

```c++
#include <bits/stdc++.h>
using namespace std;


const int N = 12, M = 1<< N;  

long long f[N][M] ;// 第一维表示列， 第二维表示所有可能的状态

bool st[M];  //存储每种状态是否有奇数个连续的0，如果奇数个0是无效状态，如果是偶数个零置为true。

//vector<int > state[M];  //二维数组记录合法的状态
vector<vector<int>> state(M);  //两种写法等价:二维数组

int m, n;

int main() {

    while (cin >> n >> m, n || m) { //读入n和m，并且不是两个0即合法输入就继续读入

        //第一部分：预处理1
        //对于每种状态，先预处理每列不能有奇数个连续的0

        for(int i = 0; i < (1 << n); i ++) {//表示n行的二进制表示（也就是每列伸出来还是没伸出的状态）的不同状态

            int cnt = 0 ;//记录连续的0的个数

            bool isValid = true; // 某种状态没有奇数个连续的0则标记为true

            for(int j = 0; j < n; j ++) { //遍历这一列，从第0列开始，从上到下

                 if ( (i >> j) & 1) {  
                     //i >> j位运算，表示i（i在此处是一种状态）的二进制数的第j位； 
                     // &1为判断该位是否为1，如果为1进入if
                    if (cnt & 1) { 
                    //这一位为1，看前面连续（这个是重点）的0的个数，如果是奇数（cnt & 1为真）则该状态不合法
                        isValid =false; break;
                    } 

                    cnt = 0; // 既然该位是1，并且前面不是奇数个0（经过上面的if判断），计数器清零。
                    //其实清不清零没有影响
                 }
                 else cnt ++; //否则的话该位还是0，则统计连续0的计数器++。
            }
            if (cnt & 1)  isValid = false; //最下面的那一段判断一下连续的0的个数

            st[i]  = isValid; //状态i是否有奇数个连续的0的情况,输入到数组st中
        }

        //第二部分：预处理2
        // 经过上面每种状态 连续0的判断，已经筛掉一些状态。
        //下面来看进一步的判断：看第i-2列伸出来的和第i-1列伸出去的是否冲突

        for (int j = 0; j < (1 << n); j ++) { //对于第i列的所有状态
            state[j].clear(); //清空上次操作遗留的状态，防止影响本次状态。

            for (int k = 0; k < (1 << n); k ++) { //对于第i-1列所有状态
                if ((j & k ) == 0 && st[ j | k]) 
                // 第i-2列伸出来的 和第i-1列伸出来的不冲突(不在同一行) 
                //解释一下st[j | k] 
                //已经知道st[]数组表示的是这一列没有连续奇数个0的情况，
                //我们要考虑的是第i-1列（第i-1列是这里的主体）中从第i-2列横插过来的，
                //还要考虑自己这一列（i-1列）横插到第i列的
                //比如 第i-2列插过来的是k=10101，第i-1列插出去到第i列的是 j =01000，
                //那么合在第i-1列，到底有多少个1呢？
                //自然想到的就是这两个操作共同的结果：两个状态或。 j | k = 01000 | 10101 = 11101
                //这个 j|k 就是当前 第i-1列的到底有几个1，即哪几行是横着放格子的

                    state[j].push_back(k);  
                    //二维数组state[j]表示第j行， 
                    //j表示 第i列“真正”可行的状态，
                    //如果第i-1列的状态k和j不冲突则压入state数组中的第j行。
                    //“真正”可行是指：既没有前后两列伸进伸出的冲突；又没有连续奇数个0。
            }

        }

        //第三部分：dp开始

        memset(f, 0, sizeof f);  
        //全部初始化为0，因为是连续读入，这里是一个清空操作。
        //类似上面的state[j].clear()

        f[0][0] = 1 ;// 这里需要回忆状态表示的定义
        //按定义这里是：前第-1列都摆好，且从-1列到第0列伸出来的状态为0的方案数。
        //首先，这里没有-1列，最少也是0列。
        //其次，没有伸出来，即没有横着摆的。即这里第0列只有竖着摆这1种状态。

        for (int i = 1; i <= m; i ++) { //遍历每一列:第i列合法范围是(0~m-1列)
            for (int j = 0; j < (1<<n); j ++) {  //遍历当前列（第i列）所有状态j
                for (auto k : state[j])    // 遍历第i-1列的状态k，如果“真正”可行，就转移
                    f[i][j] += f[i-1][k];    // 当前列的方案数就等于之前的第i-1列所有状态k的累加。
//f[i][j]一开始初始化为0了故可以直接加上            }
        }

        //最后答案是什么呢？
        //f[m][0]表示 前m-1列都处理完，并且第m-1列没有伸出来的所有方案数。
        //即整个棋盘处理完的方案数

        cout << f[m][0] << endl;

    }
}   


```



[91. 最短Hamilton路径 - AcWing题库](https://www.acwing.com/problem/content/93/)

依然是由于状态太多，需要压缩状态，而压缩状态常用二进制表示

纯暴力的话就是（这里是知道起点和终点的）

一共n个点，去掉起点和终点之后，中间还有n-2个点

故起点走到第二个点有n-2种选法，走到第三个点时有n-3种选法，所以一共要枚举(n-2)!种选法

**优化思路**

首先我们要思考如果让这个NP完全题目复杂度降低，那么可以优先考虑到使用位运算，状态压缩等解决思路。
然后接着思考，我们可以发现，我们所需要的不是整个方案，而只是方案最优解，所以我们只需要记录当前这个方案的最优解即可，那么我们考虑的状态，不久只有，在当前方案i中，目前抵达的点是j。
现在既然装填已经确定好了当前点j，那么这个j点是由哪一个状态移动而来的呢？我们可以选择k，也就是说我们的状态转移方程可以为
f[i,j]=min(f[i,j],f[i^(1<<j)，k]+weight[k，j]转移方程，weight数组为权值 ，也就是weight[k,j]是k点到j点的权值
i^(1<<j)的意思是，i 异或 1右移j位，具体来说就是i这个方案集合 xor 10……0,(其中1的位置在第j位)。
那么这个位运算有什么用处呢，第一点它是在判断第j位的情况，第二点位运算处理速度很快。

**完整代码**

```c++
#include <bits/stdc++.h>
using namespace std;
int n,f[1<<20][21],i,j,k;
//状态表示：所有从0走到j,走过的所有点的情况是i的所有路径
int weight[21][21];
int main()
{
    ios::sync_with_stdio(false);//加快cin的读入速度，但是scanf将会不能用。
    memset(f,0x3f,sizeof(f));//初始化最大值
    cin>>n;
    for (i=0; i<n; i++)
        for (j=0; j<n; j++)
            cin>>weight[i][j];
    f[1][0]=0;//第一个点是不需要任何费用的
    for (i=1; i<(1<<n); i++)//i代表着是一个方案集合，其中每一个位置1和0，代表着这个点经过还是没有经过
        for (j=0; j<n; j++)//枚举当前到了哪一个点
            if ((i>>j & 1))//如果i集合中第j位是1，也就是到达过这个点
                for (k=0; k<n; k++)//枚举到达j的点k
                    if ((i^(1<<j)) >> k & 1)//重点，判断k和j的条件，具体在上面解说
 //1 << j表示j位数比如j等于5，那二进制就是10000 ，等价于i - (1 << j)                      
                        f[i][j]=min(f[i][j],f[i^(1<<j)][k]+weight[k][j]);//选择最小值，也就是判断，k点到j点最优，还是以前的方案最优
    cout<<f[(1<<n)-1][n-1];//输出最后的最优值
    //f[f[(1<<n)-1][n-1],(1<<n)-1表示状态是全1，也就是全部都走过的，终点是n-1，就要所求答案
    return 0;
}

```

一些例题

<[P1433 吃奶酪 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1433)>

## 树形DP

### 什么是树型动态规划 

顾名思义，树型动态规划就是在“树”的数据结构上的动态规划，平时作的动态规划都是线性的或者是建立在图上的，线性的动态规划有二种方向既向前和向后，相应的线性的动态规划有二种方法既顺推与逆推，而树型动态规划是建立在树上的，所以也相应的有二个方向： 

  1、叶－>根：在回溯的时候从叶子节点往上更新信息

  2、根 - >叶：往往是在从叶往根dfs一遍之后（相当于预处理），再重新往下获取最后的答案。

  不管是 从叶－>根 还是 从 根 - >叶，两者都是根据需要采用，没有好坏高低之分。

参考<[树形 DP 总结 - miaoheping - 博客园 (cnblogs.com)](https://www.cnblogs.com/mhpp/p/6628548.html)>

<[树形$dp$学习笔记 - _Lancy - 博客园 (cnblogs.com)](https://www.cnblogs.com/ifmyt/p/9588872.html)>

**实现形式**

树形$dp$的主要实现形式是$dfs$,在$dfs$中$dp$,主要的实现形式是$dp[i][j][0/1]$,$i$是以$i$为根的子树，$j$是表示在以$i$为根的子树中选择$j$个
 子节点，0表示这个节点不选，1表示选择这个节点。有的时候$j$或0/1这一维可以压掉
 基本的$dp$方程
 **选择节点类**

$\left\{dp[i][0]=dp[j][1]\right.$ //当作一一个latex参考$\left\{\begin{array}{l}dp[i][0]=dp[j][1]\\dp[i][1]=\max/\min(dp[j][0],dp[j][1])\end{array}\right. .$

**树形背包类** 
$\left\{\begin{array}{}dp[v][k]=dp[u][k]+val\\dp[u][k]=max(dp[u][k],dp[v][k-1])\end{array}\right.$



**例题**

<[285. 没有上司的舞会 - AcWing题库](https://www.acwing.com/problem/content/description/287/)>

容易推出状态方程

所以容易推出状态转移方程：

$$
dp[0][i]=\sum_{u=sons}max(dp[1][u],dp[0][u])\text{当前节点不选,那么子节点随斌}
$$

$$
dp[1][i]=\sum_{u=sons}dp[0][u]+happy[i]\text{当前节点选,子节点不能选}
$$

**完整代码**

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 6010;
int n;
int happy[N]; //每个职工的高兴度
int f[N][2]; //上面有解释哦~
int e[N],ne[N],h[N],idx; //链表，用来模拟建一个树
bool has_father[N]; //判断当前节点是否有父节点
void add(int a,int b){ //把a插入树中
    e[idx] = b,ne[idx] = h[a],h[a] = idx ++;
}
void dfs(int u){ //开始求解题目
    f[u][1] = happy[u]; //如果选当前节点u，就可以把f[u,1]先怼上他的高兴度
    for(int i = h[u];~i;i = ne[i]){ //遍历树
        int j = e[i];
        dfs(j); //回溯
        //状态转移部分，上面有详细讲解~
        f[u][0] += max(f[j][1],f[j][0]);
        f[u][1] += f[j][0];
    }
}
int main(){
    scanf("%d",&n);
    for(int i = 1;i <= n;i ++) scanf("%d",&happy[i]); //输入每个人的高兴度
    memset(h,-1,sizeof h); //把h都赋值为-1
    for(int i = 1;i < n;i ++){
        int a,b; //对应题目中的L,K,表示b是a的上司
        scanf("%d%d",&a,&b); //输入~
        has_father[a] = true; //说明a他有爸爸（划掉）上司
        add(b,a); //把a加入到b的后面
    }
    int root = 1; //用来找根节点
    while(has_father[root]) root ++; //找根节点
    dfs(root); //从根节点开始搜索
    printf("%d\n",max(f[root][0],f[root][1])); //输出不选根节点与选根节点的最大值
    return 0;
}

```

例题<[D-小红的二进制树_牛客周赛 Round 32 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/75174/D)>

## 记忆化搜索

#### 简述

　　记忆化搜索实际上是递归来实现的，但是递归的过程中有许多的结果是被反复计算的，这样会大大降低算法的执行效率。

　　而记忆化搜索是在递归的过程中，将已经计算出来的结果保存起来，当之后的计算用到的时候直接取出结果，避免重复运算，因此极大的提高了算法的效率。

好像可以用**map来存储**然后结合find函数,也可直接用数组存储，如在下面代码中的第四行便运用了记忆化搜索

```
ll f(int x){
	if(x < 0) return 0; // 如果台阶层数小于 0，则没有方案
    if(x == 0) return 1; // 刚好走到楼梯顶端，算作一种方案
    if(dp[x] != -1) return dp[x]; // 如果已经计算过这个状态，则直接返回结果

    dp[x] = (f(x - a) + f(x - b) + f(x - c)) % N; // 计算所有可能的方案数之和，并取模

    return dp[x];
}

int main(){
	memset(dp,-1,sizeof dp);
	
	cin >> n >> a >> b >> c;
	
	cout << f(n);
}
```



这里给出一道例题分析

<[901. 滑雪 - AcWing题库](https://www.acwing.com/problem/content/903/)>

**分析思路**

1. **广度优先搜索（BFS）**：
   - BFS 是一种图搜索算法，它从起点开始，逐层遍历图中的所有节点。在这个问题中，BFS 会从滑雪场的每个点开始，尝试向四个可能的方向（上、下、左、右）滑动，并记录滑行的长度。BFS 会先处理所有与起点相邻的点，然后再处理这些点的邻居，以此类推，直到所有可达的点都被访问过。
   - BFS 的时间复杂度较高，因为它需要遍历整个图。对于这个问题，如果滑雪场很大，BFS 可能会非常慢，因为它需要处理大量的节点和边。
2. **动态规划（DP）**：
   - DP 是一种优化算法，它将问题分解为更小的子问题，并通过解决这些子问题来构建原问题的解。在这个问题中，DP 会为每个点计算一个值，表示从该点出发能够滑行的最长距离。
   - DP 的关键在于状态转移方程，它描述了如何从一个状态（即一个点的高度）转移到另一个状态（即相邻点的高度）。状态转移方程通常涉及到比较当前点的高度和相邻点的高度，以及更新最长滑行距离。
   - DP 的时间复杂度通常较低，因为它避免了重复计算。在这个问题中，DP 只需要遍历滑雪场一次，就可以找到最长的滑行轨迹。

对于这个特定的滑雪问题，动态规划是更优的选择，因为它可以有效地利用之前计算的结果，避免重复工作。而广度优先搜索虽然可以找到最长路径，但在大规模问题上可能会因为效率问题而变得不实用。动态规划通过构建一个状态表（通常是二维数组），可以快速地找到最长滑行轨迹，而不需要遍历整个滑雪场。

![98857_3fe39957af-搜狗截图20220329212159.png](C:\Users\肖翰\Downloads\typora\98857_5aab53d538-98857_3fe39957af-搜狗截图20220329212159.png)

**完整代码**

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 310;
int n,m; //网格滑雪场的行和列
int f[N][N]; //状态转移式,所有从i,j开始滑的最大路径
int h[N][N]; //网格滑雪场
int dx[4] = {-1,0,1,0};
int dy[4] = {0,1,0,-1};
int dp(int x,int y){
    int &v = f[x][y]; //Y总说的小技巧，等于把f[x][y]简化成了v，如果v发生变化，f[x][y]也会随之变化
    if(v != -1) return v; //如果已经计算过了，就可以直接返回答案
    v = 1; //注意v要先赋值为1哦~
    for(int i = 0;i < 4;i ++){ //四个方向
        int xx = x + dx[i];
        int yy = y + dy[i];
        if(xx >= 1 && xx <= n && yy >= 1 && yy <= m && h[x][y] > h[xx][yy]){ //判断这点是否能走
            v = max(v,dp(xx,yy) + 1); //更新
        }
    }
    return v; //别忘了返回v啊（被坑了
}
int main(){
    cin>>n>>m; //输入滑雪场行和列
    for(int i = 1;i <= n;i ++){
        for(int j = 1;j <= m;j ++){
            cin>>h[i][j]; //读入滑雪场数据
        }
    }
    memset(f,-1,sizeof f);
    int res = 0; //最后答案
    for(int i = 1;i <= n;i ++){
        for(int j = 1;j <= m;j ++){
            //因为这个人可以在任意一点开始滑，所以要遍历一遍滑雪场
            res = max(res,dp(i,j)); //更新答案
        }
    }
    cout<<res<<endl;
    return 0;
}


```



# 贪心

# 时空复杂度分析

#一些常用的思想

## 桶思想（鸽巢原理）

（不过桶思想似乎可以用map或者set来代替) 

**描述**

给定一个长度为$n(n\leq2×10^5)$ 的序列{${a_i}$}，其中$\forall i\in[1,n],a_i \leq2.5×10^5。$

找到一组$(x,y,z,w)$,使得$a_x+a_y=a_z+a_w$

**Solution**

首先很容易直接想到暴力，那就是四重for循环，时间复杂度为$O(n^4)$，显然远远超时，可以定义一个桶，

和的值域为 [2,5000000]，对值域开桶，当枚举对数超过值域后，一定会有两对放在同一个桶中。

```c++
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<vector>
#include<set>
#include<queue>
#include<map>
#include<stack>
#include<string>
#include<random>
#include<iomanip>
#define yes puts("yes");
#define inf 0x3f3f3f3f
#define ll long long
#define linf 0x3f3f3f3f3f3f3f3f
#define ull unsigned long long
#define endl '\n'
#define int long long
#define rep(i,a,n) for(int i = a;i <= n;i++)
#define per(i,n,a) for(int i = n;i >= a;i--)
using namespace std;
mt19937 mrand(random_device{}());
int rnd(int x) { return mrand() % x;}
typedef pair<int,int> PII;
const int MAXN =10 + 2e5 ,mod=1e9 + 7;

void solve()
{    
	int n; cin >> n;
	vector<int> a(n);
	rep(i,0,n - 1) cin >> a[i];
	vector<PII> s(5e6 + 1,make_pair(-1,-1));
	rep(i,0,n - 1) {
		rep(j,i + 1,n - 1) {
			if(s[a[i] + a[j]].first == -1) s[a[i] + a[j]] = {i,j};
			else {
				int k = a[i] + a[j];
				if(s[k].first != i && s[k].second != i
				&& s[k].first != j && s[k].second != j) {
					cout << "YES\n";
					cout << s[k].first + 1 << " " << s[k].second + 1 << " "
					<< i + 1 << " " << j + 1 << endl;
					return;
				}
			}
		}
	}
	cout << "NO\n";
}
signed main()
{
	ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);

	//int T;cin>>T;
	//while(T--)
		solve();

	return 0;
}
```

## 将y加到x取模的常用模板

```c++
void add(int &x,int y){
    x %= p;
	y %= p;
	x = ((x + y) % p + p)%p;
}
```

这段代码的目的是将整数 `y` 加到整数 `x` 上，并且保证结果模上 `p` 后是一个非负整数。这里的 `p` 通常是一个正整数，表示取模的基数。在许多编程问题中，特别是涉及数学计算的问题，我们经常需要对结果进行取模以避免整数溢出或者保持结果的范围。这段代码确保了即使在存在负数的情况下也能正确地进行模运算。

代码的每一步都有其特定的目的：

1. `y %= p;`：首先，对 `y` 进行取模操作，确保 `y` 是小于 `p` 的非负整数。这有助于减少后面计算的大小，可以避免潜在的整数溢出问题。
2. `x = ((x + y) % p + p)%p;`：这里进行了几个步骤：
   - `(x + y) % p`：将 `x` 和 `y` 相加后再对 `p` 取模，得到一个可能的负数或非负数。
   - `((x + y) % p + p)`：为了处理可能出现的负数情况，加上 `p` 可以确保结果是一个非负数。
   - `... % p`：最后再次对 `p` 取模，将结果规范到 `[0, p-1]` 的范围内。

这样写的好处是：

- **避免负数**：在某些编程语言中，取模运算可能产生负数结果，这个写法确保了最终结果始终是非负的。
- **防止溢出**：通过在每一步都进行取模操作，可以避免整数加法运算中的溢出问题。
- **结果一致**：无论输入的 `x` 和 `y` 如何，最终的结果都会是在 `[0, p-1]` 范围内的一个整数，这对于算法正确性和一致性很重要。

总之，这个函数是一个典型的、安全的方式来执行模加运算，保证了结果的正确性和范围。

## 关于阶乘

### 阶乘中末尾0的个数

可参考<[计算阶乘n!末尾0的个数 - VictoKu - 博客园 (cnblogs.com)](https://www.cnblogs.com/kuliuheng/p/4102917.html)>

<[快速求出n!的质因数的个数 - Slager_Z - 博客园 (cnblogs.com)](https://www.cnblogs.com/Slager-Z/p/7780382.html)>

两个大数字相乘，都可以拆分成多个质数相乘，而质数相乘结果尾数为0的，只可能是2*5。如果想到了这一点，那么就可以进一步想到：两个数相乘尾数0的个数其实就是依赖于2和5因子的个数。

比如 $k = 2^{m1}*3^{m2}*5^{m3}*……$

那么末尾0的个数就是min(m1,m3)，又因为$2^n<5^n$,所以$5^n$肯定先到k，故m3<m1,故末尾0的个数只跟m3有关

更具体的解释（首先，我们根据算法基础课中求n!中某个因子的个数可知：
m1=n/2+n/2^2^+n/2^3^....
m3=n/5+n/5^2^+n/5^^3^....
因为2<5，所以m1中的每一项都大于m3中的每一项，而且m1的项数一
定大于m3的项数，因为2^n^<5^n^,所以5^n^一定先到n!.
综上：1.m1的每一项都大于m3的每一项
2.ml的项数比m3的项数更多
所以m1一定大于m3;）

**一、问题描述**

　　给定一个正整数n，请计算n的阶乘n！末尾所含有“0”的个数。例如：

- 5！=120，其末尾所含有的“0”的个数为1；
- 10！= 3628800，其末尾所含有的“0”的个数为2；
- 20！= 2432902008176640000，其末尾所含有的“0”的个数为4

**二、算法分析**

　　此类问题很显然属于数学问题，一定要找到其中的本质规律才能得到正确的数学模型。

　　两个大数字相乘，都可以拆分成多个质数相乘，而质数相乘结果尾数为0的，只可能是2*5。如果想到了这一点，那么就可以进一步想到：两个数相乘尾数0的个数其实就是依赖于2和5因子的个数。又因为每两个连续数字就会有一个因子2，个数非常充足，所以此时只需要关心5因子的个数就行了。

　　对于一个正整数n来说，怎么计算n！中5因子的个数呢？我们可以把5的倍数都挑出来，即：

　　令n! = (5*K) * (5*(K-1)) * (5*(K-2)) * ... * 5 * A，其中A就是不含5因子的数相乘结果，n = 5*K + r（0<= r <= 4）。假设f(n!)是计算阶乘n!尾数0的个数，而g(n!)是计算n!中5因子的个数，那么就会有如下公式：

　　**f(n!) = g(n!) = g(5^K \* K! \* A) = K + g(K!) = K + f(K!)，其中K=n / 5（取整数）。**

 g(5^K \* K! \* A) = K + g(K!)**解释：**5^K^可以写成$\overbrace{5×5……}^{k}$因此可以拆分成k + g(k!)

　　很显然，**当0 <= n <= 4时，f(n!)=0**。结合这两个公式，就搞定了这个问题了。举几个例子来说：

- f(5!) = 1 + f(1!) = 1
- f(10!) = 2 + f(2!) = 2
- f(20!) = 4 + f(4!) = 4
- f(100!) = 20 + f(20!) = 20 + 4 + f(4!) = 24
- f(1000!) = 200 + f(200!) = 200 + 40 + f(40!) = 240 + 8 + f(8!) = 248 + 1 + f(1) =249

**三、代码实现**

```c++
#include <iostream>
using namespace std;

int GetN_1(int n)
{
    if (n < 5)
    {
        return 0;
    }
    else
    {
        return (n / 5 + GetN_1(n / 5));
    }
}

int main()
{
    cout << GetN_1(1000) << endl;　　// 输出249

    system("pause");
    return 0;
}
```

## 打印回型矩阵

```c++
#include <iostream>
#include <vector>
using namespace std;
class Solutions{
public:
    void ShowMatrix(const vector<vector<int>>& matrix) {
        int n = matrix.size();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j)
                printf("%4d ", matrix[i][j]);
            cout << endl;
        }
    }
    vector<vector<int>> Clip(const int& n) {
        vector<vector<int>> clip(n, vector<int>(n));
        int left = 0, top = 0, right = n - 1, bottom = n - 1;
        int l, r, b, t;
        int num = 1;
        while (num <= n * n) {//循环条件可换top==bottom && left==right
            l = left;
            while (l <= right)
                clip[top][l++] = num++;
            ++top;
            t = top;
            while (t <= bottom)
                clip[t++][right] = num++;
            --right;
            r = right;
            while (r >= left)
                clip[bottom][r--] = num++;
            --bottom;
            b = bottom;
            while (b >= top)
                clip[b--][left] = num++;
            ++left;
        }
        return clip;
    }
};
int main() {
    int n;
    cin >> n;
    Solutions s;
    vector<vector<int>> m(n, vector<int>(n));
    m = s.Clip(n);
    s.ShowMatrix(m);
    return 0;
}


```



这篇博客有极为详细的解释<[蛇形/回形矩阵（超详细！看了不会你来打我）_蛇形矩阵-CSDN博客](https://blog.csdn.net/qq_39208237/article/details/116833004)>

## 距离思想

例题：#### 问题陈述

有一条向东西两侧无限延伸的道路，从这条道路上的某一参考点向东$x$米处的点的**坐标**定义为$x$。其中，从参考点向西$x$米处的一点的坐标为$-x$。

斯努克将从坐标为$A$的点开始，以$M$米的间隔在路上的各点摆放圣诞树。换句话说，他将在每一个可以用某个整数$k$表示为$A+kM$的点上摆放一棵圣诞树。

高桥和青木分别站在坐标为 $L$ 和 $R$ 的点上。$(L\leq R)$。求在高桥和青木之间（包括他们所站的点）将会有多少棵圣诞树。

```c++
l a,m,l,r;

int main(){
	cin >> a >> m >> l >> r;
	ll L = l + ((a-l)%m+m)%m;//表示离左边界l最近的一颗树，(a-l)
	可以看作是l到a的距离，模m可以消除a中m的倍数
	ll R = r - ((r-a)%m+m)%m;//表示离右边界r最近的一颗树，(r-a)可以看作是a到r的距离
	
	cout << (R - L)/m + 1<< endl;
}
```

## 前后缀夹出中间的数

<[C - Socks 2 (atcoder.jp)](https://atcoder.jp/contests/abc334/tasks/abc334_c)>

#### 问题陈述

高桥有$N$双袜子，其中$i$双由两只颜色为$i$的袜子组成。一天，高桥在整理抽屉时发现自己丢失了$A_1, A_2, \dots, A_K$种颜色的袜子各一只，于是他决定用剩下的$2N-K$只袜子做$\lfloor\frac{2N-K}{2}\rfloor$双新袜子，每双由两只袜子组成。一双颜色为$i$的袜子和一双颜色为$j$的袜子的**怪异度**定义为$|i-j|$，高桥希望将总怪异度最小化。

求用剩下的袜子做成$\lfloor\frac{2N-K}{2}\rfloor$对时，总奇异度的最小值。请注意，如果$2N-K$是奇数，那么将有一只袜子不包含在任何一对袜子中。

### 思路分析

本题在k为偶数的情况下比较简单，由于丢失的袜子已经排序，只需要将相邻的丢失的袜子进行配对就行（贪心），但是当袜子为偶数时，需要找出单独的一双袜子，使其不配对，如果直接逐个枚举，时间复杂度为 *O*(*K*^2^)，显然会超时；但如果我们预先将前缀和求出来，求值部分时间复杂度就可降低到 *O*(*K*)。

![at53au5x](C:\Users\肖翰\Downloads\typora\at53au5x.png)

如果我们要删除的是图中黑色部分，那么剩下的差异和就为`e[1] + b[1] + a[4] - a[2]`。

也就是说，如果要删除第 *i* 个颜色，当 *i* 为偶数时，差异和为`b[i - 2] + e[i + 2] + a[i + 1] - a[i - 1]`；*i* 为奇数时，差异和为`b[i - 1] + e[i + 1]`。

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N = 2e5 + 10;
int n, k, a[N], ans;
int b[N], e[N];
signed main() {
	cin >> n >> k;
	for (int i = 1; i <= k; i ++ ) cin >> a[i];
   	sort(a + 1, a + 1 + k);
	if (k % 2 == 0) for (int i = 1; i <= k; i += 2) ans += a[i + 1] - a[i];//k为偶数
	else {//k为奇数
		ans = INT_MAX;
		for (int i = 2; i <= k; i += 2)//前缀和b
		    b[i] = b[i - 2] + a[i] - a[i - 1];
		for (int i = k - 1; i > 0; i -= 2)//前缀和e
		    e[i] = e[i + 2] + a[i + 1] - a[i];
		for (int i = 1; i <= k; i += 2)//删除奇数位数
		    ans = min(ans, b[i - 1] + e[i + 1]);
		for (int i = 2; i <= k; i += 2)//删除偶数位数
		    ans = min(ans, b[i - 2] + e[i + 2] + a[i + 1] - a[i - 1]);
	}
	cout << ans;//输出
}
```

## 置换环

**置换环**是用来求解**数组排序元素间所需最小交换次数**这类问题。

置换环思想：置换环将每个元素指向其排序后应在的位置，最终首位相连形成一个环**（若数字在最终位置，则其自身成环）**，可知元素之间的交换只会在同一个环内进行，而每个环内的最小交换次数为

​										$$环上元素数量-1$$

参考<[置换环 - TTS-S - 博客园 (cnblogs.com)](https://www.cnblogs.com/TTS-TTS/p/17047104.html)>

```c++
//置换环
pair<int, int> arrpos[len];//一维记录数值，一维记录位置
for(int i = 0;i < len;i++){
    arrpos[i].first = tmp[i];
    arrpos[i].second = i;
}
//跑次数
sort(arrpos,arrpos + len);
vector<int> vis(len,0);
for(int i = 0;i < len;i++){
    int cycelsize = 0;
    //自环或者访问过
    if(vis[i] || arrpos[i].second == i) continue;
    int j = i;
    while(!vis[j]){
        vis[j] = 1;
        j = arrpos[j].second;
        cycelsize += 1;
    }
    if(cycelsize > 0){
        ans += (cycelsize - 1);
    }
}

```

例题<[G-小红的元素交换_牛客周赛 Round 34 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/75766/G)>

## 树状数组

### 1.什么是树状数组？

顾名思义，就是用数组来模拟树形结构呗。那么衍生出一个问题，为什么不直接建树？答案是没必要，因为树状数组能处理的问题就没必要建树。和Trie树的构造方式有类似之处。

### 2.树状数组可以解决什么问题

可以解决大部分基于区间上的更新以及求和问题。

比如逆序对和单点的修改

### 3.树状数组和线段树的区别在哪里

树状数组可以解决的问题都可以用线段树解决，这两者的区别在哪里呢？树状数组的系数要少很多，就比如字符串模拟大数可以解决大数问题，也可以解决1+1的问题，但没人会在1+1的问题上用大数模拟。

### 4.树状数组的优点和缺点

修改和查询的复杂度都是O(logN)，而且相比线段树系数要少很多，比传统数组要快，而且容易写。

![883867-20160810150435699-1238857602](C:\Users\肖翰\Downloads\typora\883867-20160810150435699-1238857602.png)

``` c++
#include<iostream>
#include<cstdio>
using namespace std;
int tree[500001],n,m;
int lowbit(int p){
	return p & -p;
}
 void add(int x,int k)//单点修改 x：修改位置，k：修改值
 {
     while(x <= n){
         tree[x] = tree[x] + k;
         x = x + lowbit(x);
     }
 }

int sum(int x)
{
    int ans = 0;
    while(x!=0){
		ans = ans + tree[x];
        x = x - lowbit(x);
    }
    return ans;
}

int main(){
    cin >> n >> m;
    for(int i = 1; i<= n;i++){//注意树状数组一定要从1开始
        int x;
        cin >> x;
        add(i,x);//创建树状数组
    }
    for(int i = 1; i <= m;i++){
		int x,y,z;
        cin >> x >> y >> z;
        if(x == 1){//x = 1时，给y位置加z
			add(y,z);
        }
        if(x == 2){
			cout << sum(z)-sum(y-1) << endl;
        }
    }
    return 0;
}
```



## 线段树

![efc75ae5449d4ed7b84885fd55cead20](C:\Users\肖翰\Downloads\typora\efc75ae5449d4ed7b84885fd55cead20.png)

### 建树

1. 节点数组tr[]:结构体包含三个变量：l，r，sum
   l,r存区间的左右端点，sum存区间和
2. 递归建树：父节点编号为p(一开始是根节点)，左孩子编号为2\*p，右孩子编号为2\*p+1

``` c++
#define lc p << 1
#define rc p << 1 |1
#define N 500005
int n,w[N];
struct node{
	int l,r,sum;
}tr[N*4];//开4n空间防止re

void build(int p,int l,int r){
	tr[p] = {l,r,w[l]};
    if(l == r) return;//是叶子节点则返回
    int m = l+r >> 1;//不是叶子节点则裂开
    build(lc,l,m);
    build(rc,m+1,r);
    tr[p].sum = tr[lc].sum+tr[rc].sum;
}
```

### 点修改

- 例如，对x=7位置上的数加5
- 从根节点进入，递归找到叶子节点[x,x],吧该节点的值增加k。然后从下往上更新其祖先节点上的统计的值。

``` c++
void update(int p,int x,int k){//x:第几个点 k：要修改成多少
	if(tr[p].l == x&&tr[p].r == x){//叶子则修改
		tr[p].sum += k;
        return;
    }
    int m = tr[p].l+tr[p].r >> 1;//非叶子节点则裂开
    //中间将左右孩子分开
    if(x <= m) update(lc,x,k);//说明在左孩子区间内
    if(x > m) update(rc,x,k);//在右孩子区间
    tr[p].sum = tr[lc].sum+tr[rc].sum;
}
```

### 区间查询

- 拆分与拼凑的思想。例如，查询区间[4,9]可以拆分
  成[4,5]，[6,8]和[9,9]，通过合并这三个区间的答案
  求得查询答案
- 丛根节点进入，递归执行以下过程
  1.若查询区间x,y]完全覆盖当前节点区间，则立
  即回溯，并返回该节点的sum值。
  2.若左子节点与[x,y]有重叠，则递归访问左子树
  3.若右子节点与[x,y]有重叠，则递归访问右子树。

``` c++
int query(int p,int x,int y){
	if(x <= tr[p].l&&tr[p].r<=y)//覆盖则返回
        return tr[p].sum;
    int m = tr[p].l+tr[p].r >> 1;//不覆盖则裂开
    int sum = 0;
    if(x <= m) sum += query(lc,x,y);//lc表示左子树
    if(y > m) sum += query(rc,x,y);//没有覆盖就继续裂开
    return sum;
}
```

### 区间修改

- 例如，对区间[4,9]内的每个数加上5。如果修改
  区间[x,y]所覆盖的每个叶子节点，时间将是O（n）的。
- 我们做懒惰修改(node增加一个参数add)，当[x,y]完全覆盖节点区间[a,b]
  时，先修改该区间的Sum值再打上一个“懒标记
  然后立即返回。等下次需要时，再下传“懒标记”。这
  样，可以把每次修改和查询的时间都轻制到O(logn)

``` c++
struct node{
    int l,r,sum,add;
}tr[N*4];
void pushup(int p){
	//向上更新
    tr[p].sum=tr[lc].sum+tr[rc].sum;
}
void pushdown(int p){
    //向下更新
    if(tr[p].add){
        //如果有懒标记
        tr[lc].sum += tr[p].add*(tr[lc].r-tr[lc].l+1),
        tr[rc].sum += tr[p].add*(tr[rc].r-tr[rc].l+1),
        tr[lc].add += tr[p].add,
        tr[rc].add += tr[p].add,
        tr[p].add = 0;
    }
}

void update(int p,int x.int y,int k){
	if(x <= tr[p].l&&tr[p].r <= y){//覆盖则修改
        tr[p].sum += (tr[p].r-tr[p].l+1)*k;
        tr[p].add += k;
        return ;
    }
    int m = tr[p].l+tr[p].r>>1;//不覆盖则裂开
    pushdown(p);
    if(x <= m) update(lc,x,y,k);
    if(y > m) update(rc,x,y,k);
    pushup(p);
}
```

完整代码模板

``` c++

#include<iostream>

#define int long long

using namespace std;


#define lc p << 1
#define rc p << 1 | 1
const int N = 1e5 + 10;

struct node{
    int l,r;
    int sum,add;
}tr[N*4];
int a[N];
int n,m;

void pushup(int p){
    tr[p].sum = tr[lc].sum + tr[rc].sum;
}

void build(int p,int l,int r){
    tr[p] = {l, r, 0, 0}; // 初始化add和sum
    if(l == r){
        tr[p].sum = a[l];
        return; // 是叶子节点则返回
    }
    int m = l + r >> 1; // 不是叶子节点则裂开
    build(lc, l, m);
    build(rc, m + 1, r);
    pushup(p);
}

void pushdown(int p){
    // 向下更新
    if(tr[p].add){
        // 如果有懒标记
        tr[lc].sum += tr[p].add * (tr[lc].r - tr[lc].l + 1);
        tr[rc].sum += tr[p].add * (tr[rc].r - tr[rc].l + 1);
        tr[lc].add += tr[p].add;
        tr[rc].add += tr[p].add;
        tr[p].add = 0;
    }
}

int query(int p, int x, int y){
    if(x <= tr[p].l && tr[p].r <= y){
        return tr[p].sum;
    }
    pushdown(p); // 在裂开之前，先下传懒惰标记
    int m = tr[p].l + tr[p].r >> 1;
    int sum = 0;
    if(x <= m) sum += query(lc, x, y);
    if(y > m) sum += query(rc, x, y);
    return sum;
}


void update(int p, int x, int y, int k){
    if(x <= tr[p].l && tr[p].r <= y){ // 覆盖则修改
        tr[p].sum += (tr[p].r - tr[p].l + 1) * k;
        tr[p].add += k;
        return;
    }
    int m = tr[p].l + tr[p].r >> 1; // 不覆盖则裂开
    pushdown(p);
    if(x <= m) update(lc, x, y, k);
    if(y > m) update(rc, x, y, k);
    pushup(p);
}

signed main(){
    
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> a[i];
    }
    build(1, 1, n);
    while(m--){
        int op, x, y, k;
        cin >> op >> x >> y;
        if(op == 1){
            cin >> k;
            update(1, x, y, k);
        }else{
            cout << query(1, x, y) << endl;
        }
    }
}
```



**重点**

- 节点数组tr[]存{l，r,统计值，懒标记}

- pushup函数从下向上计算统计值

- pushdown函数从上向下计算统计值

  和懒标记

- 建树、修改、查询均从根节点进入

- 递归建树，时间O(n)

- 区间修改，区间查询0(logn)



## 求连续子数组的最大和

``` c++
ll ans = 0;
	for(int i = 1; i<= n;i++){
		ans = max(f[i],ans + f[i]);//这里说明要么从f[i]这里重新开始计数，要么加上f[i]
		cout << ans << endl;
		mx = max(mx,ans);
	}
```

- 遍历数组 f 从 i = 1 到 n（包含 n），对于每个元素 f[i]： 
- 使用 max(f[i], ans + f[i]) 来更新 ans。这个表达式的含义是： 
- 如果 ans + f[i] 大于 f[i]，那么将 ans 更新为 ans + f[i]，这意味着我们继续在当前子数组上累加，。这就不用从当前元素 f[i] 开始一个新的子数组。可以继续用前面的连续数组。
-  如果 f[i] 大于或等于 ans + f[i]，那么将 ans 更新为 f[i]，这意味着我们应该从当前元素 f[i] 开始一个新的子数组，因为之前的子数组和对于当前元素来说不是最优的。 
- 打印当前的 ans 值，这可能是一个中间结果，但不是最终的最大子数组和。
-  使用 max(mx, ans) 来更新 mx。这个表达式的含义是，如果我们当前的子数组和 ans 大于之前记录的最大子数组和 mx，那么我们更新 mx 为 ans。 遍历完成后，mx 将包含整个数组中连续子数组的最大和。

## 关于日期问题

主要写三个函数

1. 判断是不是闰年，如果是那么二月份要加1
2. 找一个初始点，这样我们就能固定一个数从而变化其他两个数，省去一个边界问题
3. 计算：计算初始点到第y-1年然后在加上m-1的月份最后加上day天数

``` c++
const int months[] = {0,31,28,31,30,31,30,31,31,30,31,30,31};

int is_leap(int year){
	if(year % 4 == 0&&year % 100 || year % 400 == 0)
	return 1;
	return 0;
}
int get_days(int y,int m){
	if(m == 2) return 28 + is_leap(y);
	return months[m];
}

int calc(int y,int m,int d){
	int res = 0;
	for(int i = 1;i< y;i++){
		res += 365 + is_leap(i);
	}
	for(int j = 1; j < m;j++){
		res += get_days(y,j);
	}
	return res + d;
}

int main(){

	int y1,m1,d1,y2,m2,d2;
	
	while(~scanf("%04d%02d%02d\n%4d%02d%02d",&y1,&m1,&d1,&y2,&m2,&d2))
	
	cout << abs(calc(y1,m1,d1) - calc(y2,m2,d2)) + 1 << endl;
}

```

