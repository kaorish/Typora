# 1. 算法复杂性分析

## 1.1 函数渐近表达式

课本P2~P4讲的很清楚，有很多数学符号和数学公式推导，这里就不手打了，看书一样的。

## 1.2 时间复杂度

**快速排序：**

快速排序是从大往小排，每一层都将左右两半的序列各自排好序，然后进入下一层如此往复，最后会因为整个序列只有一个元素而返回，因为一个元素不需要排序，所以此时也说明整个序列都排好序了。因为从大到小排嘛，最小的部分（子序列）都排好了，说明整个待排序序列都排好序了。

```c++
#include <iostream>
using namespace std;

const int N = 100010;

int n;
int q[N];

void quick_sort(int q[], int l, int r)
{
    if (l >= r) return; // 左边界等于右边界则说明此时只有一个数了，不需要排序；如果左边界大于右边界，更应该停止了，因为这种情况不可能发生。
    int x = q[l + r >> 1], i = l - 1, j = r + 1; // x是哨兵，最好取中间，i和j分别是指针，用来交换两个元素以完成排序
    while (i < j) // 两个指针之间起码有两个不同的元素，这样才能交换，左右交换
    {
        while (q[++i] < x); // 因为是从小到大排序，所以最终的序列要满足哨兵左边小于等于哨兵，哨兵右边大于等于哨兵
        while (q[--j] > x); // 所以只有左边大于哨兵和右边小于哨兵的情况才需要交换
        if (i < j) swap(q[i], q[j]); // 这里还需要再判断此指针之间是否起码有两个元素，因为经过两个while循环，i和j可能变的不满足了
    }
    quick_sort(q, l, j); // 递归处理左右子序列，因为每一层都会将左右两部分序列排好序，所以最后只有一个元素而退出时，就说明整个序列都排好序了
    quick_sort(q, j + 1, r);
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++) cin >> q[i];
    
    quick_sort(q, 0, n - 1); // 对下标为0到下标为n-1之间的数排序
    
    for (int i = 0; i < n; i++) cout << q[i] << ' ';
    
    return 0;
}
```

最好情况下的时间复杂度为 $O(nlogn)$，因为最好情况下每次都选中间的数作为哨兵，这样一直分下去就是要分 $logn$ 次，然后每个部分都要进行 $n$ 次的排序，因为虽然每一个部分没有 $n$ 个数，但是实际上每一层中所有元素都在各自的部分进行了排序，一共是 $n$ 次排序，所以最好情况下时间复杂度为 $O(nlogn)$。

最坏情况下的时间复杂度为 $O(n^2)$，因为最坏情况下每次都选边界的数作为哨兵，这样一直分下去就要分$n$次，因为每次分都只分了一个数出去，一共$n$个数就要分$n$次。然后每一层还是要进行$n$次排序，所以最坏情况下的时间复杂度会退化为 $O(n^2)$。

平均情况下的时间复杂度为 $O(nlogn)$。证明就算了，这是基于概率算出的结果。



还有一种证明方法是通过时间复杂性函数证明。

最好情况下每次所取的哨兵都是中间的数，则时间复杂性函数 $T(n)$ 为：
$$
T(n)=\left\{\begin{matrix} 
  O(1)  && {n\le1} \\  
  T(n-1)+O(n) && {n > 1}
\end{matrix}\right.
$$
求解该递归方程，再由时间渐近表达式的知识可得 $T(n)=O(n^2)$。



最坏情况下每次所取的哨兵都是最边缘的数，将产生的两个区域分别包含 $n-1$ 和 $1$ 个元素，则时间复杂性函数 $T(n)$ 为：
$$
T(n)=\left\{\begin{matrix} 
  O(1)  && {n\le1} \\  
  2T(n/2)+O(n) && {n > 1}
\end{matrix}\right.
$$
求解该递归方程，再由时间渐近表达式的知识可得 $T(n)=O(nlogn)$。



再提一嘴空间复杂度。快速排序是一种原地排序算法，辅助空间复杂度为 $O(1)$，但是它的递归，会使用系统的栈，而且递归深度在 $logn$ 到 $n$ 之间，所以空间复杂度不确定，在 $O(logn)$ 到 $O(n)$ 之间。



**归并排序：**

归并排序是从小往大排，和快速排序完全相反，一开局的就左右一直递归二分直至将每个部分的数组的元素都变为1个，然后再排序、归并。因为只有一个元素时，排序就是直接比较这两个元素的大小了，小的放进临时数组，大的放后面，这样临时数组就已经是有序的了，然后再覆盖原数组，接着回到倒数第二层，且该部分已经排好了序。如此往复，上面每一层都借助已经排好了序的子序列部分数组而完成排序，一直返回到上面，直到返回到第一层完成排序+归并的步骤后，整个序列就都排好了序。

```c++
#include <iostream>
using namespace std;

const int N = 100010;

int n;
int q[N], tmp[N];

void merge_sort(int q[], int l, int r)
{
    if (l >= r) return; // 左右边界之间只有一个数则不需要排序，左边界大于右边界是不可能的情况，直接退出
    
    int mid = l + r >> 1; // 从中间分割为两部分
    merge_sort(q, l, mid); // 再对左右两部分分别递归分割，直至分到每个小部分都只有一个元素为止
    merge_sort(q, mid + 1, r);
    
    int i = l, j = mid + 1, k = 0; // 然后从每个部分都只有一个元素开始排序，然后将排好序的数组覆盖原数组（归并的过程），故要借助中间数组
    while (i <= mid && j <= r) // 两个部分都没到边界，则按从小到大排序，将各自小的数放到tmp数组中
    {
        if (q[i] <= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    }
    
    while (i <= mid) tmp[k++] = q[i++]; // 收尾，左右部分可能不一样长。因为归并是从1个元素的部分开始的，所以到这里的时候两个部分各自都是从小到大有序排列的，所以剩余的部分一定是最大的，直接按顺序放到tmp后面就行
    while (j <= r) tmp[k++] = q[j++];
    
    for (int i = l, k = 0; i <= r; i++, k++) q[i] = tmp[k]; // 归并，将排序好的临时数组覆盖原数组，这样这部分就是有序的了，再返回上一层继续排序+归并，这样第一层结束后整个数组就都排好序了
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i++) cin >> q[i];
    
    merge_sort(q, 0, n - 1); // 对元素下标为0到n-1的数进行归并排序
    
    for (int i = 0; i < n; i++) cout << q[i] << ' ';
    
    return 0;
}
```

对于归并排序，由于算法策略就是确定地将数组分成大致相同的两部分，所以实际上没有最好、最坏和平均的情况，都是同一种情况，即尽量将序列分为相等的两部分。这种划分方式一共会划分 $logn$ 次，每次排序和合并的时间开销是 $O(n)$，于是时间复杂度均为 $O(nlogn)$。

方法二也是通过时间复杂性函数证明。归并排序的时间复杂性函数为：
$$
T(n)=\left\{\begin{matrix} 
  O(1)  && {n\le1} \\  
  2T(n/2)+O(n) && {n > 1}
\end{matrix}\right.
$$
求解该递归方程，再由时间渐近表达式的知识可得 $T(n)=O(nlogn)$。



其空间复杂度为 $O(n)$，因为辅助数组的容量为 $n$。它的递归过程也使用了系统栈，但是由于最大只用了 $O(logn)$，所以整体空间复杂度还是 $O(n)$。

## 1.3 时间复杂性函数

此处指的一般是递归中的递归函数，即 $T(n)$，我们一般情况下需要根据给定的 $T(n)$ 表达式推出其时间复杂度 $O(n)$。



# 2. 二分与分治

## 2.1 二分





## 2.2 分治



**循环赛日程表：**



## 2.3 二分+分治综合运用

对{15，9，115，118，3，90，27，25，5}采用归并排序进行使其成为递减序列，然后再从排好序的序列中使用二分查找找出元素z。



# 3. 动态规划



## 3.1 01背包



## 3.2 最长公共子序列



## 3.3 矩阵链乘



# 4. 贪心



## 4.1 活动安排



## 4.2 哈夫曼编码



## 4.3 贪心与背包

**为什么说01背包不能用贪心算法做，而普通背包又可以用贪心算法做？**

因为01背包的物品不可以分开来，只能选或不选，而普通背包可以分开来，也就是说普通背包可以放入分数个的物品。而对于01背包如果也计算性价比的话，很可能会因为优先放入的物品最后并不在最高价值物品的集合中，因为01背包要全局最优，达到最优的过程需要有子问题也最优，但是采用贪心的算法就真的只满足局部最优而不满足全局最优了。但普通背包没问题，就是因为普通背包的物品可以拆分为分数个，所以不必担心我选了目前性价比最高的，那剩余容量怎么办？因为可以拆开来然后填满，只不过01背包就要考虑了，所以01背包不能用贪心做。但是不代表01背包只能用动态规划做，只能说动态规划只是最适合的方法，也可以采用回溯法和分支限界法求解，反正不能用贪心做。



**怎么用贪心算法求解普通背包？**注意，普通背包就是把物品看作蛋糕，可以取0~1的任意值，也就是说可以取分数个物品，但是最多只有1个。

贪心算法是求局部最优，不在乎是否为全局最优。所以对于有限容量的背包，我们想装下最大价值的物品，就应该尽可能让装进去的物品性价比尽可能地高，这里的性价比表达式如下：
$$
性价比=\frac{代价}{价值}
$$
其中，“性”指代价，即每个物品所占的空间或者说重量，“价”指价值，即每个物品的价值，故“性价比”在此处指单位空间（重量）的价值。

只要我们每次都装入所有物品中单位价值最高的物品，那么整个背包的总价值一定是最高的。所以求解方法为：

1. 计算所有物品的性价比，即单位空间价值；
2. 在目前背包容量能放下整个物品的情况下，优先放入整个性价比最高的物品，如此循环直至背包不能再放下完整的物品；
3. 计算剩余空间，然后对于全放入目前剩下物品中性价比最高的物品，放入该物品的数量的计算公式为：

$$
数量=\frac{背包剩余容量}{该物品的代价} 
$$

也就是说，放入多少该物品可以刚好填充满背包，可以说次数算出来的几乎都是分数，因为基本上到这一步时背包已经没有足够的容量放下完整的物品了。

例题请看学习通作业5的第一题。

# 5. 回溯法与分支限界法

## 5.1 回溯法

实际上就是dfs+剪枝，递归所有可能的情况，遇到已经不可能的情况时直接return（即剪枝），大部分都和全排列、n皇后类似。



## 5.2 分支限界法

分支限界法就是bfs+剪枝，借助队列实现bfs，再与回溯类似，遇到已经不可能的情况时直接return（即剪枝）。



## 5.3 回溯法和分支限界法的异同点



## 5.4 01背包用回溯法和分支限界法



# 6. 各算法思想的区别

## 6.1 回溯法、递归与分治法三者的区别

​           

## 6.2 回溯法与分支限界法之间的区别



## 6.3 贪心与动态规划的区别



